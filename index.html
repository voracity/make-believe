<!--
Copyright (c) 2014-2015 Steven Mascaro

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!doctype HTML>
<html>
<head>
	<title>Make-Believe (R14)</title>
	<script src="jquery.min.js"></script>
	<script src="defiant.min.js"></script>
	<script src="vkbeautify.0.99.00.beta.js"></script>
	<script src="beliefUpdate_worker.js"></script>
	<script src="equationFunctions.js"></script>
	<script src="sylvester.js"></script>
	<script src="dagre.min.js"></script>
	<script src="menu.js"></script>
	<script src="utils.js"></script>
	<script src="parsing.js"></script>
	<link href="menu_styles.css" type="text/css" rel="stylesheet" />
	<script src="menu_styles.js"></script>
	<script>
	var titlePostfix = "Make-Believe (R14)";
	var openBns = [];
	var currentBn = null;

	/// I'm not sure if this guarantees a nicely formatted string.
	function sigFig(num, digits) {
		if (num==0)  return 0;
		/// Get a multiplier based on the log position of most sig digit (add 1 to avoid 100...0 not being rounded up)
		var mul = Math.pow(10,Math.floor(Math.log10(num)));
		var sigPow = Math.pow(10,digits-1);
		/// XXX: I need to work this out properly at some point
		var v = Math.round((num/mul)*sigPow);
		if ((mul/sigPow) < 1) {
			var d = Math.round(1/(mul/sigPow));
			v = v/d;
		}
		else {
			var d = Math.round(mul/sigPow);
			v = v*d;
		}
		return v;
	}

	/// Inconsistencies between html and svg are very annoying
	function makeSvg(tag, attrs) {
		var el= document.createElementNS('http://www.w3.org/2000/svg', tag);
		for (var k in attrs) {
			el.setAttribute(k, attrs[k]);
		}
		return el;
	}

	String.prototype._splitNotEmpty = function() {
		return this.length==0 ? [] : this.split.apply(this, arguments);
	}

	function getQs() {
		var params = {};
		var argSpecs = window.location.search.substring(1).split('&');
		if (window.location.search) {
			for (var i in argSpecs) {
				var argInfo = argSpecs[i].split('=');
				params[unescape(argInfo[0])] = unescape(argInfo[1]);
			}
		}
		return params;
	}

	window.qs = getQs();

	function loadFile() {
		$("#openFile").click();
	}

	function baseName(fileName) {
		var m = fileName.match(/[^/]*$/);
		if (m) {
			return m[0];
		}
		return null;
	}

	function fileLoaded(inp, callback) {
		var fileExts = {xdsl:true,dne:true};
		var file = inp.files[0];

		var fileName = baseName(file.name);
		var format = file.name.replace(/^.*\.([^.]*)$/, '$1');
		/// Assume xdsl if extension not recognised (XXX probably should at least throw a warning before
		/// the inevitable failure to load anything)
		console.log(format);
		if (!fileExts[format]) {
			format = "xdsl";
		}

		console.debug(file);
		var reader = new FileReader();
		reader.onload = function(e) {
			openBns.push(new BN({source: e.target.result, outputEl: $(".bnview"), format: format}));
			currentBn = openBns[openBns.length-1];
			currentBn.fileName = fileName;
			$(".status").text(currentBn.nodes.length+" nodes");
			if (callback)  callback();
		}
		reader.readAsText(file);
	}

	function loadFromServer(fileName, callback) {
		var fileExts = {xdsl:true,dne:true};
		var format = fileName.replace(/^.*\.([^.]*)$/, '$1');
		if (!fileExts[format]) {
			format = "xdsl";
		}
		$.get(fileName, function(data) {
			openBns.push(new BN({source: data, outputEl: $(".bnview"), format: format}));
			currentBn = openBns[openBns.length-1];
			currentBn.fileName = baseName(fileName);
			document.title = baseName(fileName) + " - " + titlePostfix;
			$(".status").text(currentBn.nodes.length+" nodes");
			if (callback)  callback();
		}, "text");
	}

	function updateBN(callback) {
		currentBn.updateAndDisplayBeliefs(null, callback);
	}

	/// From https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm
	function clone(objectToBeCloned) {
	  // Basis.
	  if (!(objectToBeCloned instanceof Object)) {
	    return objectToBeCloned;
	  }

	  var objectClone;

	  // Filter out special objects.
	  var Constructor = objectToBeCloned.constructor;
	  switch (Constructor) {
	    // Implement other special objects here.
	    case RegExp:
	      objectClone = new Constructor(objectToBeCloned);
	      break;
	    case Date:
	      objectClone = new Constructor(objectToBeCloned.getTime());
	      break;
	    default:
	      objectClone = new Constructor();
	  }

	  // Clone each property.
	  for (var prop in objectToBeCloned) {
	    objectClone[prop] = clone(objectToBeCloned[prop]);
	  }

	  return objectClone;
	}

	function newArray(size, initial) {
		var arr = new Array(size);

		for (var i=0; i<size; i++) {
			arr[i] = clone(initial);
		}

		return arr;
	}

	function renewArray(arr, initial) {
		var size = arr.length;

		for (var i=0; i<size; i++) {
			arr[i] = clone(initial);
		}

		return arr;
	}

	function numNodeStateCombinations(nodes) {
		var numNodeStates = 1;
		for (var j=0; j<nodes.length; j++) {
			numNodeStates *= nodes[j].states.length;
		}
		return numNodeStates;
	}

	function initialStates(nodes) {
		return newArray(nodes.length, 0);
	}

	function nextStates(nodes, states) {
		for (var j=nodes.length-1; j>=0; j--) {
			states[j]++;
			if (states[j] < nodes[j].states.length)  break;
			else                                      states[j] = 0;
		}
		return j >= 0;
	}

	/** Dialogs **/
	function popupDialog($a) {
		if (typeof($a)=="string") {
			$a = $("<div class=dialog>")
				.html($a)
				.appendTo("body");
		}
		var $veil = $("<div class=veil>").width($(window).width()).height($(window).height())
			.css({opacity: 0})
			.animate({opacity: 0.5}, 300)
			.appendTo($("body"));


		var w = $a.outerWidth(),
			h = $a.outerHeight();
		$a.fadeIn(300);

		$a.css({left: (($(window).width() - w)/2)+"px"});
		$a.css({top:(($(window).height() - h)/2)+"px"});

		$a.data("veil", $veil);
	}

	function reportError(msg) {
		popupDialog(msg+"<div class=controls><button type=button onclick=dismissDialogs()>OK</button></div>");
	}

	function dismissDialog($a, callback) {
		$a.fadeOut(300);
		$a.data("veil").animate({opacity: 0}, 300, function() { $(this).hide(); if (callback)  callback(); });
		$a.data("veil").remove();
		$a.remove();
	}

	function dismissDialogs(callback) {
		var first = true;
		var $dialogs = $();
		$(".dialog:visible").each(function() {
			$dialogs.add(dismissDialog($(this), first ? callback : null));
			first = false;
		});
	}
	/** End Dialogs **/

	/** To create a node, call new Node({opt1:...,opt2:...}) **/
	function Node(o) {
		/*
			Member vars and their defaults
		*/
		/// The node's ID (as per GeNIe)
		this.id = null;
		/// The node's label (equivalent to Netica's 'title', or GeNIe's 'name')
		this.label = null;
		/// Type of node: nature, decision, utility
		this.type = "nature";
		/// A list of states (state objects) XXX
		this.states = [];
		/// A map of state ids -> position in states array
		this.statesById = {};
		/// Pointers to the parents of this node
		this.parents = [];
		/// Cache of parent state values
		this.parentStates = [];
		/// Pointers to the children of this node
		this.children = [];
		/// The CPT, preferably as a typed float array (only if discrete probabilistic)
		this.cpt = null;
		/// The deterministic function table (only if discrete deterministic)
		this.funcTable = null;
		/// The function for this node (which can be any javascript function that returns a real value)
		this.func = null;
		/// The utilities associated with this node's states
		this.utilities = [];
		/// The current beliefs for this node (net must have been updated separately)
		this.beliefs = null;
		/// 'counts' (per state) and 'seen' (for the whole node) are generated
		/// during simulation belief update. A little bit
		/// like 'experience' in Netica, but not really.
		this.counts = null;
		this.seen = 0;
		/// 'samples' are for continuous nodes, and are a list of all the samples
		/// created for this node
		this.samples = [];
		/// In a DBN, the time-dependent version of the CPT/funcTable (e.g. t=0, t=1, etc. within a CPT in GeNIe)
		this.dbnOrder = 0;
		/// In a DBN, what temporal step this node falls into
		this.slice = 0;
		/// Whether this node is a dynamic node
		this.dynamic = false;
		/// Parents of nodes in slices t>0. Each parent should be specified as [<parent>,<order>]
		this.dynamicParents = [];
		/// Whether this node should be visible to the engine only, and not the user
		this.engineOnly = false;

		/// Does the display need updating?
		this._updateDisplay = false;

		/// Visual properties
		this.pos = {x: 0, y: 0};
		this.size = {width: 0, height: 0};
		/// For arc drawing/updating
		this.pathsIn = [];
		this.pathsOut = [];

		/// Set options based on constructor args
		for (var i in o) {
			this[i] = o[i];
		}
	}
	Node.prototype = {
		numParentCombinations: function() {
			var numParentStates = 1;
			for (var j=0; j<this.parents.length; j++) {
				numParentStates *= this.parents[j].states.length;
			}
			return numParentStates;
		},
		getRow: function(i) {
			return Array.prototype.slice.call(this.cpt, i*this.states.length, i*this.states.length+this.states.length);
		},
		removeStates: function() {
			/// XXX This will leave CPTs, etc. in an inconsistent state at this point
			this.states = [];
			this.statesById = {};
		},
		addStates: function(newStates) {
			for (var i=0; i<newStates.length; i++) {
				var stateName = newStates[i];
				this.states.push({id: stateName});
				this.statesById[stateName] = this.states.length-1;
			}
		},
		discretizeFromSamples: function() {
			var node = this;
			var maxStates = 10;
			/// Do we have something that looks discrete?
			var samplesSeen = new Map();
			for (var j=0; j<node.samples.length; j++) {
				samplesSeen.set(node.samples[j], (samplesSeen.get(node.samples[j]) || 0) + 1);
				if (samplesSeen.size > maxStates)  break;
			}
			if (samplesSeen.size <= maxStates) {
				var states = [];
				samplesSeen.forEach(function(v,k) {
					states.push([k,v]);
				});
				states.sort(function(a,b) { return a[0] - b[0] });
				var labels = [];
				var beliefs = [];
				for (var j=0; j<states.length; j++) {
					labels.push(states[j][0]);
					beliefs.push(states[j][1]/node.samples.length);
				}
				node.removeStates();
				node.addStates(labels);
				node.beliefs = beliefs;
			}
			else {
				var discInfo = generateMultinomialFromSamples(node.samples, maxStates);
				node.removeStates();
				var labels = [];
				for (var j=0; j<discInfo.boundaries.length-1; j++) {
					labels[j] = '['+sigFig(discInfo.boundaries[j],3)+"-"+sigFig(discInfo.boundaries[j+1],3);
					labels[j] += (j+2==discInfo.boundaries.length) ? ']' : ')';
				}
				node.addStates(labels);
				node.beliefs = discInfo.bins;
			}
			node._updateDisplay = true;
		}
	};

	/**
	'engineOnly' means node is only visible to the engine, not in the interface
	**/
	function makeNodeFromXdslEl(el, $xdsl, opts) {
		opts = opts || {};
		opts.engineOnly = opts.engineOnly || false;

		var $el = $(el);
		var states = $el.find("state").toArray().map(function(a){ return {id:$(a).attr("id")}; });
		var stateIndex = {}; states.forEach(function(a,i) { stateIndex[a.id] = i; });
		var cpt = null;
		var funcTable = null;
		var func = null;
		var funcDef = null;
		var utils = null;

		if ($el.is("cpt")) {
			cpt = $el.find("probabilities").text()._splitNotEmpty(/\s+/).map(function(p){return parseFloat(p)});
		}
		else if ($el.is("deterministic")) {
			var map = $el.find("resultingstates").text()._splitNotEmpty(/\s+/);
			funcTable = [];
			for (var i in map) {
				funcTable.push( stateIndex[map[i]] );
			}
			/*/// Go through and convert/expand each row from single-deterministic value to probabilities
			cpt = [];
			for (var i in map) {
				var toState = stateIndex[map[i]];
				console.log("toState:", toState);
				for (var j=0; j<states.length; j++) {
					cpt.push(toState==j ? 1 : 0);
				}
			}
			console.log(cpt);*/
		}
		else if ($el.is("equation")) {
			/// Do the minimum conversion needed to get it into JS
			/// XXX-fix: Properly parse the equation!
			/// Note: Parents will always be in the order defined here, so this approach is fine
			var pars = $el.find("parents").text().split(/\s+/);
			var bodyDef = $el.find("definition").text().replace(new RegExp('^'+$el.attr('id')+'\\s*=\\s*', 'g'), '');
			for (var p=0; p<pars.length; p++) {
				if (pars[p]) {
					console.log(pars, bodyDef);
					bodyDef = bodyDef.replace(new RegExp('\\b'+pars[p]+'\\b', 'g'), '__pars['+p+']');
					console.log(pars, bodyDef);
				}
			}
			funcDef = [
				'__pars',
				'return '+bodyDef
			];
			//func = new Function(funcDef[0], funcDef[1]);
		}
		else if ($el.is("decision")) {
			/// Replace with uniform CPT --- later, though, because we don't necessarily know
			/// enough about the parents yet
		}
		else if ($el.is("utility")) {
			utils = $el.find("utilities").text()._splitNotEmpty(/\s+/).map(function(p){return parseFloat(p)});
			states = utils.map(function(a){ return {id: a} });
			funcTable = [];
			for (var i in utils) {
				funcTable[i] = i;
			}
		}
		var $extInfo = $xdsl.find("> extensions > genie > node#"+$el.attr("id"));
		var posInfo = $extInfo.find("position").text().split(/\s+/);

		/// We will define what we can for Node, and then fix things
		/// up later.
		var node = new Node({
			id: $el.attr("id"),
			label: $el.attr("name"),
			type: $el.is("decision") ? "decision" : $el.is("utility") ? "utility" : "nature",
			states: states,
			parents: $el.find("parents").text()._splitNotEmpty(/\s+/),
			cpt: cpt,
			funcTable: funcTable,
			func: func,
			funcDef: funcDef,
			utilities: utils,
			dbnOrder: $el.is("[order]") ? Number($el.attr("order")) : 0,
			dynamic: $el.attr("dynamic")=="plate",
			engineOnly: opts.engineOnly,
			pos: {x: Number(posInfo[0]), y: Number(posInfo[1])},
			size: {width: Number(posInfo[2])-Number(posInfo[0]), height: Number(posInfo[3])-Number(posInfo[1])},
		});
		console.log(node, $extInfo);
		node.beliefs = new Float32Array(new ArrayBuffer(node.states.length*4));
		node.counts = new Int32Array(new ArrayBuffer(node.states.length*4));
		node.parentStates = new Float32Array(new ArrayBuffer(node.parents.length*4));
		return node;
	}

	function BN(o) {
		o = o || {};
		o.format = o.format || "xdsl";

		this.source = o.source;
		this.sourceFormat = o.format;
		this.outputEl = $(o.outputEl);

		/// Use worker threads to do belief updating?
		this.useWorkers = true;
		this._workers = [];
		this.numWorkers = 2;

		this.evidence = {};

		/// Does the cache information need updating?
		this.cacheDirty = false;
		/// (No longer true: These are intended to be cache-only. To update the net, call the modification functions
		/// (once they''re written!) or change this.objs and then call this.updateCache.)
		this.nodes = [];
		this._utilityNodes = [];
		this._decisionNodes = [];
		this.nodesById = {};
		this._rootNodes = [];
		this._nodeOrdering = [];

		this.getRowIInts = new Int32Array(new ArrayBuffer(2*4));

		this.init();
	}
	BN.prototype = {
		init: function() {
			this.iterations = 1000;

			this["load_"+this.sourceFormat](this.source);
			this.display();
		},
		/// All load/save functions for different formats have the format 'load_<format>' or
		/// 'save_<format>'.
		load_xdsl: function(xdsl) {
			this.objs = $(xdsl);

			var bn = this;
			this.nodes = [];
			this._utilityNodes = [];
			this._decisionNodes = [];
			this.nodesById = {};
			this._rootNodes = [];
			this.objs.find("> nodes cpt, > nodes deterministic, > nodes decision, > nodes utility, > nodes equation").each(function() {
				var node = makeNodeFromXdslEl(this, bn.objs);
				bn.nodes.push(node);
				bn.nodesById[node.id] = node;
				if ($(this).is("utility")) {
					bn._utilityNodes.push(node);
				}
				else if ($(this).is("decision")) {
					bn._decisionNodes.push(node);
				}
				//onsole.debug(bn.nodes);
			});

			if (this._decisionNodes.length) {
				$(".decisionNet").css('display', 'inline');
			}
			else {
				$(".decisionNet").hide();
			}

			/*this.objs.find("> nodes utility").each(function() {
				var node = makeNodeFromXdslEl(this, bn.objs);
				/// Keep utility nodes separate from the nodes involved in inference
				bn._utilityNodes.push(node);
				/// Just add to the standard node index
				bn.nodesById[node.id] = node;
			});*/

			/// Augment the nodes with any dynamic nodes (including unrolled nodes...)
			this.objs.find("> dynamic").each(function() {
				var $dyn = $(this);
				var nodesInSlice = [];
				numSlices = $dyn.attr("numslices");
				///Override with 10
				numSlices = 10;
				var sliceNum = 1;

				for (; sliceNum<numSlices; sliceNum++) {
					function updateParentNames(node) {
						for (var pi=0; pi<node.parents.length; pi++) {
							var parentName = node.parents[pi];
							var parentSlice = sliceNum-node.dbnOrder;
							if (parentSlice!=0) {
								node.parents[pi] = parentName +"_"+(sliceNum-node.dbnOrder);
							}
						}
					}

					bn.objs.find("> nodes cpt, > nodes deterministic, > nodes decision, > nodes utility").each(function() {
						var node = makeNodeFromXdslEl(this, bn.objs, {engineOnly:true});
						node.id = node.id +"_"+ sliceNum;
						node.slice = sliceNum;
						bn.nodes.push(node);
						bn.nodesById[node.id] = node;
						updateParentNames(node);
						//onsole.debug(bn.nodes);
					});

					$dyn.find("> cpt, > deterministic, > nodes decision, > nodes utility").each(function() {
						var tempNode = makeNodeFromXdslEl(this, bn.objs, {engineOnly:true});
						tempNode.id = tempNode.id+"_"+sliceNum;
						var node = bn.nodesById[tempNode.id];

						/// If we've seen enough slices to accommodate the node's DBN order,
						/// start including the node in network
						if (sliceNum >= tempNode.dbnOrder) {
							/// Merge in parents for this slice
							updateParentNames(tempNode);
							if (tempNode.parents)  node.parents = node.parents.concat(tempNode.parents);
							/// Use the cpt for this slice
							node.cpt = tempNode.cpt;
						}
					});
				}

			});

			/// Store the parents/order of all dynamic nodes (useful for display)
			this.objs.find("> dynamic > cpt").each(function() {
				var node = bn.nodesById[$(this).attr("id")];
				var parentNames = $(this).find("parents").text().split(/\s+/);
				for (var pi=0; pi<parentNames.length; pi++) {
					node.dynamicParents.push( [bn.nodesById[parentNames[pi]], Number($(this).find("cpt").attr("order")) ] );
				}
			});

			console.log(bn.nodes);

			this.loadPostprocess();
		},
		load_dne: function(dneText) {
			var bn = this;
			var grammar = new Grammar($('.dneGrammar')[0].textContent);
			console.log(dneText);
			window.globalDneText = dneText;
			var om = grammar.createTree(dneText);
			console.log(om);
			var bnet = JSON.search(om, '//*[type="BLOCK_STATEMENT"][children[1]="bnet"]')[0];
			console.log(bnet);
			var nodes = JSON.search(bnet, '//*[type="BLOCK_STATEMENT"][children[1]="node"]');
			for (var ni=0; ni<nodes.length; ni++) {
				var omNode = nodes[ni];
				console.log(omNode);
				/// ASSUME represents a text node?
				var skipNode = false;
				try {
					skipNode = JSON.search(omNode, '//*[children[1]="kind"]/children[3]/children')[0]=="ASSUME";
				}
				catch (e) { skipNode = true; }
				if (skipNode)  continue;
				var centerPos = JSON.search(omNode, '//*[children[1]="center"]/children[3]/children')[0].replace(/[\(\)\s]/g, '')._splitNotEmpty(/,/);
				var states = JSON.search(omNode, '//*[children[1]="states"]/children[3]/children')[0].replace(/[\(\)\s]/g, '')._splitNotEmpty(/,/);
				states = states.map(function(x){ return {id: x} });
				var cpt = null;
				try {
					cpt = JSON.search(omNode, '//*[children[1]="probs"]/children[3]/children')[0].replace(/[\(\)\s\n\r]|&[^&;]+;/g, '')._splitNotEmpty(/,/);
				}
				catch (e) {}
				console.log("CPT:", cpt);
				var node = new Node({
					id: omNode.children[1],
					parents: JSON.search(omNode, '//*[children[1]="parents"]/children[3]/children')[0].replace(/[\(\)\s]/g, '')._splitNotEmpty(/,/),
					states: states,
					cpt: cpt,
					pos: {x: Number(centerPos[0]), y: Number(centerPos[1])},
					size: {width: 80, height: 30},
				});
				bn.nodes.push(node);
				bn.nodesById[node.id] = node;
				console.log(node);
			}
			this.loadPostprocess();
		},
		/** After basic loading, need to run various cleanups, replace named objects with object points,
		    store things in more optimised form, etc. **/
		loadPostprocess: function() {
			var bn = this;
			/// Replace references to parent ids, with references to node cache
			/// and index each node''s children
			/// The var i in bn.nodes approach causes a 4x slowdown in inference!
			/// Presumably because intId can't be pegged as an int.
			/// Update: I later learnt for x in arr forces x to always be a string
			/// based on the JS specification. Odd.
			for (var i=0; i<bn.nodes.length; i++) {
			//for (var i in bn.nodes) {
				var node = bn.nodes[i];
				/// For fast referencing (without going to a dict lookup)
				node.intId = i;
				for (var j in node.parents) {
					console.log(node.parents, j, node.parents[j]);
					node.parents[j] = bn.nodesById[node.parents[j]];
					node.parents[j].children.push(node);
				}
				for (var j in node.states) {
					node.statesById[node.states[j].id] = j;
				}
				console.log(node._name, node);
			}
			/// Set uniform CPTs for decision nodes
			for (var i in bn.nodes) {
				var node = bn.nodes[i];
				if (node.type == "decision" || !node.cpt) {
					var len = node.numParentCombinations()*node.states.length;
					var cpt = [];
					for (var j=0; j<len; j++) {
						cpt.push(1/node.states.length);
					}
					node.cpt = cpt;
				}
			}
			/// Replace ordinary CPT arrays with typed arrays
			for (var i in bn.nodes) {
				var node = bn.nodes[i];
				if (ArrayBuffer) {
					if (node.cpt) {
						var cptBuf = new ArrayBuffer(node.cpt.length*4);
						var newCpt = new Float32Array(cptBuf);
						for (var i=0; i<node.cpt.length; i++) {
							newCpt[i] = node.cpt[i];
						}
						node.cpt = newCpt;
					}
					else if (node.funcTable) {
						var ftBuf = new ArrayBuffer(node.funcTable.length*4);
						var newFt = new Int32Array(ftBuf);
						for (var i=0; i<node.funcTable.length; i++) {
							newFt[i] = node.funcTable[i];
						}
						node.funcTable = newFt;
					}
				}
			}
			/// Cache root nodes
			for (var i in bn.nodes) {
				var node = bn.nodes[i];
				if (node.parents.length == 0) {
					bn._rootNodes.push(node);
				}
			}


			function arcCopies(node) {
				node._tempParents = node.parents.slice();
			}
			for (var i=0; i<bn.nodes.length; i++)  arcCopies(bn.nodes[i]);

			/// Create a node ordering that can be used to generate cases quickly (from roots down)
			var q = bn._rootNodes.slice();
			var no = [];
			for (var i=0; i<q.length; i++) {
				var node = q[i];
				no.push(node);
				for (var j=0; j<node.children.length; j++) {
					var allParentsRemoved = true;
					for (var k=0; k<node.children[j]._tempParents.length; k++) {
						if (node.children[j]._tempParents[k] == node) {
							node.children[j]._tempParents[k] = null;
						}
						if (node.children[j]._tempParents[k] != null) {
							allParentsRemoved = false;
						}
					}
					if (allParentsRemoved) {
						q.push(node.children[j]);
					}
				}
			}
			this._nodeOrdering = q;
			console.log("nodeOrdering:", this._nodeOrdering.length);
		},
		/// Returns an xdsl string
		save_xdsl: function() {
			var bn = this;
			var $smile = $("<smile version='1.0' id='sub0'>")
				/// XXX Clarify the difference btw numsamples/discsamples
				.attr("numsamples", this.iterations)
				.attr("discsamples", this.iterations);
			$smile.append("<nodes>");
			for (var i=0; i<this.nodes.length; i++) {
				var node = this.nodes[i];
				if (node.type=="nature") {
					if (node.cpt) {
						var $el = null;
						$smile.find("> nodes").append(
							$el = $("<cpt>").attr("id", node.id)
						);
						(function(){
						for (var i=0; i<node.states.length; i++) {
							var $state = $("<state>").attr("id", node.states[i].id);
							$el.append($state);
						}
						var $parents = $("<parents>");
						var p = "";
						for (var i=0; i<node.parents.length; i++) {
							p += (i!=0?" ":"") + node.parents[i].id;
						}
						if (p!=="")  $el.append($parents.text(p));
						$el.append(
							$("<probabilities>").text(Array.prototype.slice.call(node.cpt).join(" "))
						);
						})();
					}
					else if (node.funcTable) {
						var $el = null;
						$smile.find("> nodes").append(
							$el = $("<deterministic>").attr("id", node.id)
						);
						(function(){
						for (var i=0; i<node.states.length; i++) {
							var $state = $("<state>").attr("id", node.states[i].id);
							$el.append($state);
						}
						var $parents = $("<parents>");
						var p = "";
						for (var i=0; i<node.parents.length; i++) {
							p += (i!=0?" ":"") + node.parents[i].id;
						}
						if (p!=="")  $el.append($parents.text(p));
						$el.append(
							$("<resultingstates>").text(Array.prototype.slice.call(node.funcTable).map(function(s){return node.states[s].id;}).join(" "))
						);
						})();
					}
				}
				else if (node.type == "decision") {
					var $el = null;
					$smile.find("> nodes").append(
						$el = $("<decision>").attr("id", node.id)
					);
					(function(){
					for (var i=0; i<node.states.length; i++) {
						var $state = $("<state>").attr("id", node.states[i].id);
						$el.append($state);
					}
					var $parents = $("<parents>");
					var p = "";
					for (var i=0; i<node.parents.length; i++) {
						p += (i!=0?" ":"") + node.parents[i].id;
					}
					if (p!=="")  $el.append($parents.text(p));
					})();
				}
				else if (node.type == "utility") {
					var $el = null;
					$smile.find("> nodes").append(
						$el = $("<utility>").attr("id", node.id)
					);
					(function(){
					var $parents = $("<parents>");
					var p = "";
					for (var i=0; i<node.parents.length; i++) {
						p += (i!=0?" ":"") + node.parents[i].id;
					}
					if (p!=="")  $el.append($parents.text(p));
					$el.append(
						$("<utilities>").text(Array.prototype.slice.call(node.funcTable).map(function(s){return node.states[s].id;}).join(" "))
					);
					})();
				}
			}
			$smile.append(
				'<extensions><genie version="1.0" app="GeNIe 2.0.5219.0" name="Sub0" faultnameformat="nodestate"></genie></extensions>'
			);
			for (var i=0; i<this.nodes.length; i++) {
				var node = this.nodes[i];
				var $node = $("<node>").attr("id", node.id);
				$node
					.append($("<name>").text(node.label ? node.label : node.id))
					.append($("<position>").text(node.pos.x+" "+node.pos.y+" "+(node.pos.x+node.size.width)+" "+(node.pos.y+node.size.height)))
					/// GeNIe is awfully fussy
					.append('<interior color="e5f6f7" />\
				<outline color="0000bb" />\
				<font color="000000" name="Arial" size="8" />')
				$smile.find("> extensions > genie").append($node);
			}
			return vkbeautify.xml('<?xml version="1.0"?>' + $smile[0].outerHTML).replace(/\r?\n/g, '\r\n');
		},
		setUpdateMethod: function(method) {
			this.updateBeliefs = this["updateBeliefs_"+method];
		},
		updateBeliefs: function() {
			currentBn.expectedValue = null;

			this.updateBeliefs_local();

			/// XXXXXX Calculating net's current expected value
			if (this._utilityNodes.length) {
				var totalUtility = 0;
				for (var i=0; i<this._utilityNodes.length; i++) {
					var uNode = this._utilityNodes[i];
					var ev = 0;
					for (var i in uNode.utilities) {
						ev += uNode.utilities[i]*uNode.beliefs[i];
					}
					totalUtility += ev;
				}
				currentBn.expectedValue = totalUtility;
			}
		},
		updateBeliefs_worker: function(callback, iterations) {
			if (!iterations) { iterations = this.iterations; }
			var bn = this;
			/// Extract the key parts of the BN needed to do the inference
			var bnToPass = {nodes: []};
			for (var k in bn) {
				if (typeof(bn[k])!="function") {
					bnToPass[k] = bn[k];
				}
			}
			for (var i=0; i<bnToPass.nodes.length; i++) {
				bnToPass.nodes[i].func = null;
			}
			bnToPass.objs = null;
			bnToPass.outputEl = null;
			bnToPass._workers = null;

			/// Convert evidence to array
			var evidenceArr = new Int32Array(new ArrayBuffer(bn.nodes.length*4));
			for (var i=0; i<evidenceArr.length; i++)  evidenceArr[i] = -1;
			for (var i in this.evidence)  evidenceArr[bn.nodesById[i].intId] = Number(this.evidence[i]);

			var numWorkers = this.numWorkers;

			/// Make the workers and store the BN just once
			if (!this._workers.length) {
				this._workers = [];
				for (var wi=0; wi<numWorkers; wi++) {
					this._workers[wi] = new Worker("beliefUpdate_worker.js");
					this._workers[wi].postMessage([0, bnToPass]);
				}
			}

			if (false) {
				updateBeliefs_local(bnToPass, evidenceArr);
				if (callback)  callback(bn);
			}
			else {
				var numComplete = 0;
				for (var wi=0; wi<numWorkers; wi++) {
					var w = this._workers[wi];
					w.postMessage([1, evidenceArr, Math.ceil(iterations/numWorkers)]);
					w.onmessage = function(e) {
						if (e.data[0]==0) {
							numComplete++;
							var workerBeliefs = e.data[1];
							var workerSamples = e.data[2];
							for (var i=0; i<workerBeliefs.length; i++) {
								/*console.log(workerBn.nodes[i].id, workerBn.nodes[i].beliefs);*/
								if (numComplete==1) {
									bn.nodes[i].beliefs = workerBeliefs[i];
									bn.nodes[i].samples = workerSamples[i];
								}
								else {
									var allBeliefs = bn.nodes[i].beliefs;
									var allSamples = Array.prototype.slice.call(bn.nodes[i].samples);
									for (var bi=0; bi<allBeliefs.length; bi++) {
										allBeliefs[bi] += workerBeliefs[i][bi];
										if (numComplete == numWorkers) {
											allBeliefs[bi] /= numComplete;
										}
									}
									allSamples.concat(workerSamples[i]);
									if (bn.nodes[i].funcDef && numComplete == numWorkers) {
										bn.nodes[i].discretizeFromSamples();
									}
								}
							}
							if (numComplete == numWorkers) {
								if (callback)  callback(bn);
							}
						}
						else if (e.data[0] == 1) {
							console.log(e.data);
						}
					};
				}
			}
		},
		updateBeliefs_local: function(iterations) {
			if (!iterations) { iterations = this.iterations; }
			var bn = this;

			/// Convert evidence to array
			var evidenceArr = new Int32Array(new ArrayBuffer(bn.nodes.length*4));
			for (var i=0; i<evidenceArr.length; i++)  evidenceArr[i] = -1;
			for (var i in this.evidence)  evidenceArr[bn.nodesById[i].intId] = Number(this.evidence[i]);

			updateBeliefs_local(bn, evidenceArr, iterations);

			for (var i=0; i<bn.nodes.length; i++) {
				var node = bn.nodes[i];
				if (node.func) {
					node.discretizeFromSamples();
				}
				else {
					for (var j=0; j<node.beliefs.length; j++) {
						if (node.seen>0)  node.beliefs[j] = node.counts[j]/node.seen;
					}
				}
			}
			return;

			/*if (!iterations) { iterations = this.iterations; }
			var bn = this;
			var cas = new Int32Array(new ArrayBuffer(bn.nodes.length*4));
			/// XXX Use following when have continuous (and write code to handle properly)
			var realCas = new Float32Array(new ArrayBuffer(bn.nodes.length*4));

			for (var i=0; i<bn.nodes.length; i++) {
				var node = bn.nodes[i];
				renewArray(node.counts, 0);
				node.seen = 0;
				if (node.funcDef) {
					node.func = new Function(node.funcDef[0], node.funcDef[1]);
					/// XXX Just to test it out. This is way slower than an Int32Array (about 3 times slower)
					if (i==0)  cas = new Float32Array(new ArrayBuffer(bn.nodes.length*4));
					node.samples = [];
				}
			}

			/// Convert evidence to array
			var evidenceArr = new Int32Array(new ArrayBuffer(bn.nodes.length*4));
			for (var i=0; i<evidenceArr.length; i++)  evidenceArr[i] = -1;
			for (var i in this.evidence)  evidenceArr[bn.nodesById[i].intId] = Number(this.evidence[i]);

			/// Generate cases
			for (var i=0; i<this.iterations; i++) {
				var weight = this.generateCase(evidenceArr, cas, realCas);

				/// For each state of a non-E node, count occurrence given E
				//onsole.log(evidenceArr, Array.apply([], cas), weight);
				for (var intId=0; intId<cas.length; intId++) {
					var node = bn.nodes[intId];
					if (node.func) {
						node.samples.push(cas[intId]);
					}
					else {
						//node.counts[cas[v]] += 1;
						//node.seen += 1;
						// Do likelihood weighting instead
						node.counts[cas[intId]] += weight;
						node.seen += weight;
					}
				}
			}

			for (var i=0; i<bn.nodes.length; i++) {
				var node = bn.nodes[i];
				if (node.func) {
					node.discretizeFromSamples();
				}
				else {
					for (var j=0; j<node.beliefs.length; j++) {
						if (node.seen>0)  node.beliefs[j] = node.counts[j]/node.seen;
					}
				}
			}*/
		},
		generateCase: function(evidence, cas) {
			var bn = this;

			var weight = 1;

			/// Run through nodes in topological order
			var numNodes = bn._nodeOrdering.length;
			var ni=0;
			for (;ni < numNodes; ni++) {
				var _node = bn._nodeOrdering[ni];
				cas[_node.intId] = 0;

				/** I believe inlining this is very slightly quicker **/
				//var rowI = this._getRowI(_node.parents, cas);
				var parents = _node.parents;
				var rowI = 0;
				var multiplier = 1;
				for (var pi=parents.length-1; pi>=0; pi--) {
					rowI += multiplier*cas[parents[pi].intId];
					multiplier *= parents[pi].states.length;
				}
				//return rowI;

				if (_node.func) {
					/// Evidence not supported yet!
					if (evidence[_node.intId] != -1) {

					}
					else {
						/// Generate value for node
						var parents = _node.parents;
						for (var pi=0; pi<parents.length; pi++) {
							_node.parentStates[pi] = cas[parents[pi].intId];
						}
						cas[_node.intId] = _node.func(_node.parentStates);
					}
				}
				else if (_node.cpt) {
					if (evidence[_node.intId] != -1) {
						/// Force evidence
						cas[_node.intId] = evidence[_node.intId];

						/// Calculate likelihood of evidence
						var likelihood = _node.cpt[rowI*_node.states.length + cas[_node.intId]];
						weight *= likelihood;
					}
					else {
						/// Generate state for node
						var stateProbs = _node.cpt;

						var parents = _node.parents;
						//onsole.debug("parents", parents);

						var currentSum = 0;
						var rowStart = rowI*_node.states.length;
						var rowEnd = (rowI+1)*_node.states.length-1;
						//onsole.debug("rowStart/End", parents, rowI, rowStart, rowEnd, Array.apply([], _node.cpt).slice(rowStart,rowEnd+1));
						var r = Math.random();
						for (var i=rowStart; i<=rowEnd; i++) {
							var stateProb = stateProbs[i];
							currentSum += stateProb;
							//onsole.debug(r, currentSum);
							if (r < currentSum) {
								cas[_node.intId] = (i-rowStart);
								break;
							}
						}
					}
				}
				else if (_node.funcTable) {
					if (evidence[_node.intId] != -1) {
						/// Force evidence
						cas[_node.intId] = evidence[_node.intId];

						/// Calculate likelihood of evidence (which is either 0 or 1)
						weight *= (_node.funcTable[rowI] == cas[_node.intId] ? 1 : 0);
					}
					else {
						/// Get the deterministic state
						cas[_node.intId] = _node.funcTable[rowI];
					}
				}
			}

			return weight;
		},
		_getRowI: function(parents, cas) {
			var rowI = 0;
			var multiplier = 1;
			for (var pi=parents.length-1; pi>=0; pi--) {
				rowI += multiplier*cas[parents[pi].intId];
				multiplier *= parents[pi].states.length;
			}
			return rowI;
		},
		searchDecisionsAll: function() {
			var decStates = initialStates(this._decisionNodes);
			var origEvidence = $.extend({}, this.evidence);
			var combList = new Array(numNodeStateCombinations(this._decisionNodes));
			origIterations = this.iterations;
			this.iterations = 1000;
			var j = 0;
			window.iter = 0;
			do {
				window.iter++;
				for (var i=0; i<decStates.length; i++) {
					this.evidence[this._decisionNodes[i].id] = decStates[i];
				}
				this.updateBeliefs();
				combList[j] = [this.expectedValue,JSON.stringify(decStates)];
				j++;
			} while (nextStates(this._decisionNodes, decStates));
			this.iterations = origIterations;
			this.evidence = origEvidence;
			combList.sort(function(a,b) {
				return b[0] - a[0];
			});
			var list = [];
			for (var i=0; i<20 && i<combList.length; i++) {
				var decStates = JSON.parse(combList[i][1]);
				var str = "";
				var sep = "";
				for (var d=0; d<decStates.length; d++) {
					str += sep + this._decisionNodes[d].id+'='+this._decisionNodes[d].states[decStates[d]].id;
					sep = ", ";
				}
				list.push(str+" --> "+combList[i][0]);
			}
			//onsole.log(combList);
			return list;
		},
		/// XXX: This is not done right. (Should be OK for dec nodes, but not anything else.) Need to fix.
		topologicalSort: function(nodes) {
			/// Create a node ordering that can be used to generate cases quickly (from roots down)
			var q = [];

			/// Create copies of parents, that we can freely modify
			for (var i=0; i<nodes.length; i++) {
				nodes[i]._tempParents = [];
				for (var j=0; j<nodes[i].parents.length; j++) {
					/// Only add parents from 'nodes'
					if (nodes.indexOf(nodes[i].parents[j])!=-1) {
						nodes[i]._tempParents.push(nodes[i].parents[j]);
					}
				}
			}

			/// Start with finding root nodes
			for (var i=0; i<nodes.length; i++) {
				if (nodes[i]._tempParents.length==0) {
					q.push(nodes[i]);
				}
			}

			/// q starts with root nodes only
			for (var i=0; i<q.length; i++) {
				var node = q[i];
				/// Only keep children which are in 'nodes'
				var childNodes = [];
				for (var j=0; j<node.children.length; j++) {
					if (nodes.indexOf(node.children[j])!=-1) {
						childNodes.push(node.children[j]);
					}
				}
				for (var j=0; j<childNodes.length; j++) {
					var allParentsRemoved = true;
					for (var k=0; k<childNodes[j]._tempParents.length; k++) {
						if (childNodes[j]._tempParents[k] == node) {
							childNodes[j]._tempParents[k] = null;
						}
						if (childNodes[j]._tempParents[k] != null) {
							allParentsRemoved = false;
						}
					}
					if (allParentsRemoved) {
						q.push(childNodes[j]);
					}
				}
			}
			return q;
		},
		searchDecisionsOrdered: function() {
			var decNodes = this.topologicalSort(this._decisionNodes);
			var decStates = [];
			var origEvidence = $.extend({}, this.evidence);
			var origIterations = this.iterations;
			this.iterations = 10000;
			for (var i=0; i<decNodes.length; i++) {
				var maxJ = -1;
				var maxEv = -1;
				for (var j=0; j<decNodes[i].states.length; j++) {
					this.evidence[decNodes[i].id] = j;
					this.updateBeliefs();
					if (this.expectedValue > maxEv) {
						maxEv = this.expectedValue;
						maxJ = j;
					}
				}
				decStates[i] = maxJ;
				this.evidence[decNodes[i].id] = maxJ;
			}
			this.updateBeliefs();
			ev = this.expectedValue;
			this.iterations = origIterations;
			this.evidence = origEvidence;
			return [ev, JSON.stringify(decStates)];
		},
		perfTest: function() {
			console.profile("Starting...");
			this.updateBeliefs_local(1000);
			console.profileEnd("Stopped.");
			console.debug(this.nodes);
		},
		perfCheck: function() {
			var t, dt, st = 0;
			for (var i=0; i<this.perfLoops; i++) {
				t = performance.now();
				this.updateBeliefs_local(this.perfIterations);
				dt = performance.now() - t;
				st += dt;
			}
			alert(st/100);
		},
		perfCheckWorker: function() {
			var bn = this;
			var t, dt, st = 0;
			var i = -1;
			t = performance.now();
			(function u() {
				i++;
				if (i>0) {
					dt = performance.now() - t;
					st += dt;
				}
				if (i<bn.perfLoops) {
					t = performance.now();
					bn.updateBeliefs_worker(u, this.perfIterations);
				}
				else {
					alert(st/100);
				}
			})();
		},
		/// nodeRef: for now, the id as a string
		getBeliefs: function(nodeRef) {

		},
		getAllBeliefs: function() {

		},
		getDbnNodeInstances: function(id) {
			var sliceNum = 0;
			var sliceNodes = [];

			while (true) {
				var sliceNode = this.nodesById[id+(sliceNum==0 ? "" : "_"+sliceNum)];
				if (!sliceNode)  break;

				sliceNodes.push(sliceNode);
				sliceNum++;
			}

			return sliceNodes;
		},
		setNodeStates: function(nodes, state) {
			//currentBn.nodesById[nodeId].statesById[$(this).text()]
			for (var i=0; i<nodes.length; i++) {
				currentBn.evidence[nodes[i].id] = state;
			}
		},
		getDbnBeliefs: function(id) {
			var sliceNum = 0;
			var allBeliefs = [];

			while (true) {
				var sliceNode = this.nodesById[id+(sliceNum==0 ? "" : "_"+sliceNum)];
				if (!sliceNode)  break;
				allBeliefs.push(sliceNode.beliefs);
				sliceNum++;
			}

			return allBeliefs;
		},
	};

	var draw = {
		createSvg: function(outputEl, x, y, width, height, cls) {
			return $("<svg width="+(width)+" height="+(height)+"><defs>\
					<marker id='arrowhead' viewBox='0 0 10 10' refX='10' refY='5' \
					markerUnits='strokeWidth' orient='auto'\
					markerWidth='10' markerHeight='9'>\
					<polyline points='0,0 10,5 0,10 1,5' fill=black/>\
					</marker>\
					</defs></svg>")
				.attr("class", cls)
				.css({left: x, top: y, position: "absolute"})
				.appendTo(outputEl);
		},
		getAngle: function(refVector, angledVector) {
			var r = Math.atan2(angledVector[0], angledVector[1]) - Math.atan2(refVector[0], refVector[1]);
			if (r > Math.PI)  r -= 2*Math.PI;
			else if (r < -Math.PI)  r += 2*Math.PI;
			if (r < 0)  r += 2*Math.PI;
			return r;
		},
		getBox: function(el) {
			el = $(el);
			return {x: el.position().left, y: el.position().top, width: el.outerWidth(), height: el.outerHeight()};
		},
		drawArrow: function(outputEl, from, to) {
			var sx = sy = 10; //startX, startY
			var width = Math.abs(from.x - to.x);
			var height = Math.abs(from.y - to.y);

			var $svg = null;
			var insideSvg = $(outputEl)[0].tagName.toUpperCase() == "SVG";

			if (insideSvg) {
				$svg = $(outputEl);
			}
			else {
				$svg = $("<svg width="+(width+20)+" height="+(height+20)+"><defs>\
					<marker id='arrowhead' viewBox='0 0 10 10' refX='10' refY='5' \
					markerUnits='strokeWidth' orient='auto'\
					markerWidth='10' markerHeight='9'>\
					<polyline points='0,0 10,5 0,10 1,5' fill=black/>\
					</marker>\
					</defs></svg>").appendTo(outputEl);
			}

			var firstX, firstY, lastX, lastY, svgX, svgY;
			if (from.x < to.x) { firstX = sx; lastX = sx+width; svgX = from.x; }
			else { firstX = sx+width; lastX = sx; svgX = to.x; }
			if (from.y < to.y) { firstY = sy; lastY = sy+height; svgY = from.y; }
			else { firstY = sy+height; lastY = sy; svgY = to.y; }

			//onsole.debug(svgX, svgY);
			var path = null;
			if (insideSvg) {
				$svg.append(path = makeSvg("path", {
					d: "M "+(svgX-sx+firstX)+" "+(svgY-sy+firstY)+" L "+(svgX-sx+lastX)+" "+(svgY-sy+lastY),
					stroke: "black",
					"stroke-width": 1,
					"marker-end": "url(#arrowhead)"
				}));
			}
			else {
				$svg.append(path = makeSvg("path", {
					d: "M "+firstX+" "+firstY+" L "+lastX+" "+lastY,
					stroke: "black",
					"stroke-width": 1,
					"marker-end": "url(#arrowhead)"
				}))
					.css({left: svgX-sx, top: svgY-sy, position: "absolute"});
			}
			return path;
		},
		makePolyline: function(width, height, viewWidth, viewHeight, points) {
			var pointsStr = "";
			for (var i=0; i<points.length; i++) {
				pointsStr += points[i][0]+","+points[i][1]+" ";
			}
			return $("<svg width="+(width)+" height="+(height)+" viewBox='0 0 "+viewWidth+" "+viewHeight+"'>\
				<polyline points='"+pointsStr+"' style='fill:none;stroke:black'/>\
				</svg>");
		},
		makeProbabilityLine: function(width, height, points) {
			var fmtPoints = [];
			for (var i=0; i<points.length; i++)  fmtPoints.push([i/(points.length-1)*width,height-points[i]*height]);
			return this.makePolyline(width, height, width, height, fmtPoints);
		},
		drawArrowBetweenBoxes: function(outputEl, par, child) {
			/// Calculate the line that runs between the center of the two boxes
			var parX = par.x + par.width/2;
			var parY = par.y + par.height/2;
			var childX = child.x + child.width/2;
			var childY = child.y + child.height/2;

			/// In the coordinate space of the center point
			var diagVector = [par.width/2, par.height/2];
			var arrowVector = [childX - parX, childY - parY];
			/// These run from 0 to 2PI. The "origin" line starts at about 135 degrees on a typical X-Y plane and moves anti-clockwise
			var angleBetweenDiags = draw.getAngle([-diagVector[0], -diagVector[1]], [-diagVector[0], diagVector[1]]);
			var angleBetween = draw.getAngle([-diagVector[0], -diagVector[1]], arrowVector);
			//onsole.debug("X:", diagVector, arrowVector, angleBetweenDiags, angleBetween);
			var parIntersect = null;
			if (angleBetween < angleBetweenDiags) {
				var p1 = $L([parX, parY], arrowVector),
					p2 = $L([par.x,par.y], [0,1]);
				parIntersect = p1.intersectionWith(p2);
			}
			else if (angleBetween < Math.PI) {
				var p1 = $L([parX, parY], arrowVector),
					p2 = $L([par.x+par.width,par.y+par.height], [1,0]);
				parIntersect = p1.intersectionWith(p2);
			}
			else if (angleBetween < Math.PI + angleBetweenDiags) {
				var p1 = $L([parX,parY], arrowVector),
					p2 = $L([par.x+par.width,par.y+par.height], [0,1]);
				parIntersect = p1.intersectionWith(p2);
			}
			else {
				var p1 = $L([parX, parY], arrowVector),
					p2 = $L([par.x,par.y], [1,0]);
				parIntersect = p1.intersectionWith(p2);
			}

			/// In the coordinate space of the center point
			var diagVector = [child.width/2, child.height/2];
			var arrowVector = [parX - childX, parY - childY];
			/// These run from 0 to 2PI. The "origin" line starts at about 135 degrees on a typical X-Y plane and moves anti-clockwise
			var angleBetweenDiags = draw.getAngle([-diagVector[0], -diagVector[1]], [-diagVector[0], diagVector[1]]);
			var angleBetween = draw.getAngle([-diagVector[0], -diagVector[1]], arrowVector);
			//onsole.debug("X:", diagVector, arrowVector, angleBetweenDiags, angleBetween);
			var childIntersect = null;
			if (angleBetween < angleBetweenDiags) {
				var p1 = $L([childX, childY], arrowVector),
					p2 = $L([child.x,child.y], [0,1]);
				childIntersect = p1.intersectionWith(p2);
			}
			else if (angleBetween < Math.PI) {
				var p1 = $L([childX, childY], arrowVector),
					p2 = $L([child.x+child.width,child.y+child.height], [1,0]);
				childIntersect = p1.intersectionWith(p2);
			}
			else if (angleBetween < Math.PI + angleBetweenDiags) {
				var p1 = $L([childX,childY], arrowVector),
					p2 = $L([child.x+child.width,child.y+child.height], [0,1]);
				childIntersect = p1.intersectionWith(p2);
			}
			else {
				var p1 = $L([childX, childY], arrowVector),
					p2 = $L([child.x,child.y], [1,0]);
				childIntersect = p1.intersectionWith(p2);
			}

			/// If we've been given a path, just update the d attribute
			if ($(outputEl)[0].tagName.toUpperCase() == "PATH") {
				var p = {x: parIntersect.e(1), y: parIntersect.e(2)}, c = {x: childIntersect.e(1), y: childIntersect.e(2)};
				return $(outputEl).attr("d", "M "+p.x+" "+p.y+" L "+c.x+" "+c.y);
			}
			else {
				return draw.drawArrow(outputEl, {x: parIntersect.e(1), y: parIntersect.e(2)}, {x: childIntersect.e(1), y: childIntersect.e(2)});
			}
		},
	};

	/// Add display capabilities to the BN
	BN.prototype = $.extend(BN.prototype, {
		updateAndDisplayBeliefs: function(outputEl, callback) {
			var bn = this;
			if (this.useWorkers) {
				this.updateBeliefs_worker(function() {
					bn.displayBeliefs(outputEl);
					if (callback)  callback(bn);
				});
			}
			else {
				this.updateBeliefs();
				this.displayBeliefs(outputEl);
				if (callback)  callback(this);
			}
		},
		displayBeliefs: function(outputEl) {
			outputEl = outputEl || this.outputEl;
			for (var i in this.nodes) {
				var node = this.nodes[i];
				if (node.slice != 0)  break;

				var $displayNode = outputEl.find("#display_"+node.id);
				if (node._updateDisplay) {
					this.displayNode(outputEl, node, $displayNode);
					node._updateDisplay = false;
				}
				var stateI = 0;
				var allBeliefs = this.getDbnBeliefs(node.id);
				$displayNode.find(".state").each(function() {
					if (node.dynamic) {
						$(this).find(".beliefBarView").html(
							draw.makeProbabilityLine(100, 20, allBeliefs.map(function(a){ return a[stateI]; })).css("border", "solid 1px #ccc")
						);
					}
					else {
						var pc = Math.round(node.beliefs[stateI]*1000)/1000;
						$(this).find(".prob").text(String(pc).replace(/^0\./, '.'));
						$(this).find(".beliefBar").css({width:(pc*100)+'%'});
					}
					stateI++;
				});
			}

			if (this._utilityNodes.length) {
				if (!$(".status .expectedValue").length) {
					$(".status").append('<span class=expectedValue title="Expected value (or utility) of the current network">Expected value: <span class=val></span></span>');
				}
				$(".status .expectedValue .val").text(Math.round(this.expectedValue*1000)/1000);
			}
		},
		displayNode: function(outputEl, node, $displayNode) {
			if (!$displayNode) {
				$displayNode = $("<div class=node id=display_"+node.id+" draggable=true>")
					.css({left: node.pos.x+"px", top: node.pos.y+"px"})
					.append(
						$("<h6>").text(node.label ? node.label : node.id)
					)
					.appendTo(outputEl);
			}
			if (node.dynamic)  $displayNode.addClass("dynamic");
			$displayNode.addClass(node.type);
			/// Clear out any existing states first
			$displayNode.find(".state").remove();
			for (var j=0; j<node.states.length; j++) {
				var state = node.states[j];
				$displayNode.append(
					$("<div class=state>").append(
						$("<div class=stateName>").text(state.id)
					).append(
						$("\
						<div class=prob></div>\
						<div class=beliefBarView>\
							<div class=beliefBar></div>\
						</div>\
						")
					)
				);
			}

			return $displayNode;
		},
		display: function(outputEl) {
			outputEl = outputEl || this.outputEl;
			outputEl.empty();
			var bn = this;
			var displayNodes = {};
			var nodeBeliefs = this.getAllBeliefs();
			/// Setup an SVG canvas on which to draw things. At this stage,
			/// this will just be arrows.
			/// Need to wait for nodes to be drawn before we know size
			draw.createSvg(outputEl, 0, 0, 10, 10, "netSvgCanvas");

			/// Draw all the nodes
			var maxX = 0;
			var maxY = 0;
			for (var i=0; i<bn.nodes.length; i++) {
				var node = bn.nodes[i];
				if (node.engineOnly)  continue;

				var $displayNode = this.displayNode(outputEl, node);
				displayNodes[node.id] = $displayNode;

				/// Get max x/y as extents for canvas
				var b = draw.getBox($displayNode);
				maxX = Math.max(maxX, b.x+b.width);
				maxY = Math.max(maxY, b.y+b.height);
			}

			/// Resize the SVG
			//console.log(maxX, maxY);
			$(".netSvgCanvas").attr("width", maxX).attr("height", maxY);

			/// Draw all the arcs
			var allNodes = bn.nodes;
			for (var ni=0; ni<allNodes.length; ni++) {
				var node = allNodes[ni];
				if (node.engineOnly)  continue;

				/// XXX Remove dependency on XDSL
				var parents = node.parents.concat(node.dynamicParents);
				if (parents.length) {
					for (var i=0; i<parents.length; i++) {
						/// Clarify: Parents will be an array if from dynamicParents, maybe?
						var parent = Array.isArray(parents[i]) ? parents[i][0] : parents[i];
						var n = displayNodes[parent.id];
						var par = draw.getBox(n);
						//onsole.log("par:", parents[i], par);
						n = displayNodes[node.id];
						var child = draw.getBox(n);
						//onsole.log("child:", node.id, child);

						var path = draw.drawArrowBetweenBoxes($(".netSvgCanvas"), par, child);
						$(path).attr("id", (""+Math.random()).replace(/\./, '_'));
						/// XXX Update these if nodes can be deleted
						node.pathsIn.push([$(path).attr("id"),parent]);
						parent.pathsOut.push([$(path).attr("id"),node]);
					}
				}
			}
		},
		redrawArcs: function(node, width, height) {
			var $node = this.outputEl.find("#display_"+node.id);

			/// Update max x/y as extents for canvas if necessary
			var b = draw.getBox($node);
			var maxX = Math.max(width, b.x+b.width);
			var maxY = Math.max(height, b.y+b.height);
			if (maxX != width || maxY != height) {
				$(".netSvgCanvas").attr("width", maxX).attr("height", maxY);
			}

			for (var i=0; i<node.pathsIn.length; i++) {
				var $parent = this.outputEl.find("#display_"+node.pathsIn[i][1].id);
				draw.drawArrowBetweenBoxes($("#"+node.pathsIn[i][0]), draw.getBox($parent), draw.getBox($node));
			}
			for (var i=0; i<node.pathsOut.length; i++) {
				var $child = this.outputEl.find("#display_"+node.pathsOut[i][1].id);
				draw.drawArrowBetweenBoxes($("#"+node.pathsOut[i][0]), draw.getBox($node), draw.getBox($child));
			}
		},
		resizeCanvasToFit: function() {
			var maxX = 0;
			var maxY = 0;
			for (var i=0; i<currentBn.nodes.length; i++) {
				var node = currentBn.nodes[i];
				var $displayNode = $("#display_"+node.id);
				/// Get max x/y as extents for canvas
				var b = draw.getBox($displayNode);
				maxX = Math.max(maxX, b.x+b.width);
				maxY = Math.max(maxY, b.y+b.height);
			}
			$(".netSvgCanvas").attr("width", maxX).attr("height", maxY);
		},
	});

	var app = {
		loadFile: function() {
			loadFile();
		},
		saveFile: function() {
			$("a#download")
				.attr('href', 'data:text/plain;base64,'+window.btoa(currentBn.save_xdsl()))
				.attr('download', currentBn.fileName.replace(/\.\w*$/, '.xdsl'))
				[0].click();
		},
		updateBN: function() {
			var start = performance.now();
			updateBN(function() {
				var durationMs = (performance.now() - start);
				if ($(".status .duration").length==0) {
					$(".status").append("<span class=duration title='Time taken for last computation'>Last: <span class=val></span>ms</span>");
				}
				$(".status .duration .val").text(Math.round(durationMs*1000)/1000);
			});
		},
		findGoodDecisions: function() {
			if (!currentBn._decisionNodes.length) {
				popupDialog("<p>This network has no decision nodes.<div class=controls><button type=button class=okButton>OK</button></div>");
				$(".dialog .okButton").one("click", dismissDialogs);
				return;
			}
			var str = "";
			var dec;
			if (numNodeStateCombinations(currentBn._decisionNodes) < 100) {
				dec = currentBn.searchDecisionsAll();
			}
			else {
				str += "<strong>Too many decision combinations. Using decision order instead.</strong>";
				dec = currentBn.searchDecisionsOrdered();
			}
			for (var i=0; i<dec.length; i++) {
				str += "<div>"+dec[i] + "</div>";
			}
			popupDialog(str+"<div class=controls><button type=button class=okButton>OK</button></div>");
			$(".dialog .okButton").one("click", dismissDialogs);
		},
		autoLayout: function() {
			var g = new dagre.graphlib.Graph();
			g.setGraph({});
			g.setDefaultEdgeLabel(function(){ return {}; });

			for (var i=0; i < currentBn.nodes.length; i++) {
				var node = currentBn.nodes[i];
				var $node = $("#display_"+node.id);
				var width = $node.outerWidth();
				var height = $node.outerHeight();
				g.setNode(node.id, { label: (node.label || node.id), width: width, height: height} );
			}

			for (var i=0; i < currentBn.nodes.length; i++) {
				var node = currentBn.nodes[i];
				for (var j=0; j < node.children.length; j++) {
					g.setEdge(node.id, node.children[j].id);
				}
			}

			dagre.layout(g);

			g.nodes().forEach(function(nodeId) {
				//console.log(currentBn.nodesById[nodeId]);
				var x = Math.round(g.node(nodeId).x), y = Math.round(g.node(nodeId).y);
				currentBn.nodesById[nodeId].pos.x = x;
				currentBn.nodesById[nodeId].pos.y = y;
				$("#display_"+nodeId).css({top: y, left: x});
			});

			for (var i=0; i<currentBn.nodes.length; i++) {
				var node = currentBn.nodes[i];
				var $child = $("#display_"+node.id);
				for (var j=0; j<node.pathsIn.length; j++) {
					$parent = $("#display_"+node.pathsIn[j][1].id);
					draw.drawArrowBetweenBoxes($("#"+node.pathsIn[j][0]), draw.getBox($parent), draw.getBox($child));
				}
			}

			currentBn.resizeCanvasToFit();
			/*currentBn.display();
			currentBn.displayBeliefs();*/
		},
	};

	$(document).ready(function() {
		var exampleBns = "Asia.xdsl|Cancer.dne|Continuous Test.xdsl|RS Latch.xdsl|Umbrella.xdsl|Water.xdsl".split(/\|/);
		var exampleBnActions = [];
		for (var i in exampleBns) {
			/// Need html escape function
			exampleBnActions[i] = MenuAction('<span data-name="'+exampleBns[i]+'" style="white-space: nowrap;">'+exampleBns[i]+'</span>', function() {
				window.location.href = "?file=bns/"+$(this).find('span').data("name");
			});
		}

		var menu = Menu({type: "bar", items: [
			Menu({label:"File", items: [
				MenuAction("Open...", function(){ app.loadFile(); dismissActiveMenus(); }),
				MenuAction("Save...", function(){ app.saveFile(); dismissActiveMenus(); }),
				Menu({label: "Example BNs&nbsp;&nbsp; &#9656;", items: exampleBnActions}),
			]}),
			Menu({label:"View", items: [
				MenuAction('<input type="range" name="viewZoom" min="0.25" max="3" step="0.25" value="1"> <span class="viewZoomText">100%</span>', function(){}),
			]}),
			Menu({label:"Network", items: [
				MenuAction("Update", function() { app.updateBN(); dismissActiveMenus(); }),
				MenuAction("Find Good Decisions", function() { app.findGoodDecisions(); dismissActiveMenus(); }),
				MenuAction("Auto-Layout", function() { app.autoLayout(); dismissActiveMenus(); }),
				MenuAction('# Samples: <input type="text" name="iterations" value="1000">', function() { }),
			]}),
			Menu({label:"(Debug)", items: [
				MenuAction('# Workers: <input type="text" name="numWorkers" value="2">', function() { }),
				MenuAction('# Perf Loops: <input type="text" name="perfLoops" value="100">', function() { }),
				MenuAction('# Perf Samples: <input type="text" name="perfIterations" value="1000">', function() { }),
				MenuAction('Perf Check Local', function() { currentBn.perfCheck(); }),
				MenuAction('Perf Check Worker', function() { currentBn.perfCheckWorker(); }),
			]}),
		]});

		$("body").prepend(menu.make());

		$(".bnview").on("click", ".stateName", function() {
			var nodeId = $(this).closest(".node").attr("id").replace(/^display_/, '');
			var node = currentBn.nodesById[nodeId];
			var stateI = node.statesById[$(this).text()];
			if (node.dynamic) {
				var checks = "";
				var selectStr = "<select>";
				selectStr += "<option value=-1>(not set)</option>";
				for (var i=0; i<node.states.length; i++) {
					selectStr += "<option value="+i+">"+node.states[i].id+"</option>";
				}
				selectStr += "</select>";
				for (var i=0; i<10; i++) {
					checks += "<div class='timestep time"+i+"'>"+selectStr+"</div>";
				}
				popupDialog("Please specify the evidence for each time slice:"
					+checks
					+"<div class=controls><button type=button class='okButton'>OK</button></div>");
				var t = 0;
				$(".dialog .timestep").each(function() {
					$(this).find("select").val( currentBn.evidence[nodeId+(t==0?"":"_"+t)] );
					t++;
				});
				$(".dialog .okButton").one("click", function() {
					var t = 0;
					$(".dialog").find(".timestep").each(function() {
						var timeStepVal = $(this).find("select").val();

						if (timeStepVal == -1) {
							delete currentBn.evidence[nodeId+(t==0?"":"_"+t)];
						}
						else {
							currentBn.evidence[nodeId+(t==0?"":"_"+t)] = Number(timeStepVal);
						}
						t++;
					});
					dismissDialogs(function(){currentBn.updateAndDisplayBeliefs()});
				});
			}
			else {
				if (currentBn.evidence[nodeId]) {
					/// Remove the evidence
					var isNewState = currentBn.evidence[nodeId] != stateI;
					delete currentBn.evidence[nodeId];
					/// Set new evidence
					if (isNewState) {
						currentBn.evidence[nodeId] = stateI;
					}
					/// Remove visual indicator of evidence if no new evidence
					else {
						$("#display_"+nodeId).removeClass("hasEvidence");
					}
				}
				else {
					/// Save the evidence
					currentBn.evidence[nodeId] = stateI;

					/// Update display
					$("#display_"+nodeId).addClass("hasEvidence");
				}
				app.updateBN();
			}
		});

		var mx = 0, my = 0;
		$(".bnview").on("mousedown", ".node h6", function(event) {
			mx = event.originalEvent.pageX;
			my = event.originalEvent.pageY;
			var $node = $(this).closest(".node");
			var o = $(this).offset();

			/// Get the width/height if the mousedown node were not part of the network
			var maxX = 0, maxY = 0;
			for (var i=0; i<currentBn.nodes.length; i++) {
				if (("display_"+currentBn.nodes[i].id)==$node.attr("id"))  continue;
				var n = draw.getBox($("#display_"+currentBn.nodes[i].id));
				maxX = Math.max(maxX, n.x+n.width);
				maxY = Math.max(maxY, n.y+n.height);
			}

			$(".bnview").on("mousemove", function(event) {
				var nmx = event.originalEvent.pageX;
				var nmy = event.originalEvent.pageY;
				/// Move the DOM object, but not the net object yet
				$node.offset({left: o.left + (nmx - mx), top: o.top + (nmy - my)});
				var n = currentBn.nodesById[$node.attr("id").replace(/^display_/,"")];
				currentBn.redrawArcs(n, maxX, maxY);
			});
			$(".bnview").one("mouseup", function(event) {
				/// Update position of the node
				var nmx = event.originalEvent.pageX;
				var nmy = event.originalEvent.pageY;
				$node.offset({left: o.left + (nmx - mx), top: o.top + (nmy - my)});
				$(".bnview").unbind("mousemove");

				/// Now it's final, update the net object
				var n = currentBn.nodesById[$node.attr("id").replace(/^display_/,"")];
				n.pos.x += (nmx - mx);
				n.pos.y += (nmy - my);
				/*var $extInfo = currentBn.objs.find("> extensions > genie > node#"+$node.attr("id").replace(/^display_/,""));
				var pos = $extInfo.find("position").text().split(/\s+/);
				$extInfo.find("position").text((Number(pos[0]) + (nmx - mx))+" "+(Number(pos[1]) + (nmy - my)));*/

				/// Update the arcs going into/out of this node
				currentBn.redrawArcs(n, maxX, maxY);

				/// Need something much more efficient than this!
				/*$("#beliefBarAnimations")[0].sheet.disabled = true;
				currentBn.display();
				currentBn.displayBeliefs();
				/// Turn them back on, but not in the current execution block
				window.setTimeout(function() {
					$("#beliefBarAnimations")[0].sheet.disabled = false;
				}, 0);*/
			});
		});

		$(document).on("dblclick", ".node", function() {
			var $table = $("<table>");
			var node = currentBn.nodesById[$(this).attr("id").replace(/^display_/, '')];
			var npc = node.numParentCombinations();
			for (var i=0; i<npc; i++) {
				var row = node.getRow(i);
				var $tr = $("<tr>");
				for (var j=0; j<row.length; j++) {
					$tr.append("<td>"+sigFig(row[j],3)+"</td>");
				}
				$table.append($tr);
			}
			popupDialog("<h2>CPT</h2>"+$("<div>").append($table).html()
				+"<div class=controls><button type=button class='okButton'>OK</button></div>");
			$(".dialog .okButton").one("click", dismissDialogs);
		});

		$("[name=viewZoom]").on("input change", function(evt) {
			var $range = $(evt.target);
			$(".bnview").css({transformOrigin: 'top left', transform: 'scale('+$range.val()+')'});
			$(".viewZoomText").text(Math.round($range.val()*100)+"%");
		}).on("dblclick", function(evt) {
			var $range = $(evt.target);
			$range.val(1);
			$range.trigger("change");
		});

		/// Handle an example BN load
		$(".exampleBns").on("change", function() {
			window.location.href = "?file=bns/"+$(this).find("option:selected").text();
		});

		/// Handle changes to iterations
		$("[name=iterations]").on("keyup", function(evt) {
			var numIterations = $(evt.target).val();
			currentBn.iterations = numIterations;
		});
		$("[name=perfLoops]").on("keyup", function(evt) {
			var numLoops = $(evt.target).val();
			currentBn.perfLoops = numLoops;
		});
		$("[name=perfIterations]").on("keyup", function(evt) {
			var numIterations = $(evt.target).val();
			currentBn.perfIterations = numIterations;
		});
		$("[name=numWorkers]").on("keyup", function(evt) {
			var numWorkers = $(evt.target).val();
			currentBn.numWorkers = parseInt(numWorkers);
		});

		if (window.qs.file) {
			loadFromServer(window.qs.file, updateBN);
		}
	});
	</script>
	<style>
	html, body { height: 100%; width: 100%; margin: 0; padding: 0; }

	body { font-size: 8pt; font-family: arial; }
	.bnview { width: 100%; height: 100%; position: relative; }
	.node { position: absolute; padding: 0 0; border-radius: 0; border: solid 1px #444;
		background: #F9DAB9; z-index: 1; font-family: arial; }
	.node.hasEvidence { background: #FFA87F; }
	.node h6 { font-size: 1em; margin: 0; font-weight: bold; border-bottom: solid 1px #444; padding: 1px; }
	.node.labelledBox .state { display: none; }
	.node.labelledBox { border-radius: 5px; }
	.node .state { display: table-row; cursor: pointer; }
	.node .state > div { display: table-cell; vertical-align: middle; padding: 1px; }
	.node .state .prob { width: 22px; text-align: left; padding-left: 8px; }
	.node .state .beliefBarView { min-width: 50px; position: relative; }
	.node.dynamic .state .beliefBarView { min-width: 100px; height: 26px; }
	.node .state .beliefBar { background: black; height: 10px; width: 0px; }

	.node.decision { background: #A5BEF2; }
	.node.decision .state .prob { visibility: hidden; }
	.node.decision .state .beliefBar { visibility: hidden; }
	.node.decision.hasEvidence .state .beliefBar { visibility: visible; }
	.node.utility { background: #F3A5CD; }
	.node.utility h6 { border-bottom: none; }

	/** Layout **/
	body { display: flex; flex-direction: column; height: 100%; }
	.bnouterview { flex: 1; overflow: auto; width: 100%; }
	.status { background: white;
		border-top: 1px solid #AAA;
		width: 100%; z-index: 1000; opacity: 0.8; }
	.status .expectedValue, .status .duration { margin-left: 1em; }
	.decisionNet { display: none; }

	/** Menus **/
	.menu.bar { border-bottom: 1px solid #aaa; }

	/** Dialogs **/
	.dialog { display: none; position: absolute; z-index: 10000; background: rgb(255,255,255); background: rgba(255,255,255,0.95);
		border: solid 1px black; box-shadow: 2px 2px 2px #888; padding: 1.2em; text-align: center; }
	.dialog.page { width: 80%; height: 70%; }
	.veil { position: absolute; z-index: 1000; background: white; opacity: 0; top: 0; left: 0; }
	</style>
	<style id="beliefBarAnimations">
	.node .state .beliefBar { transition: width 0.3s; }
	</style>
</head>
<body>
	<div class="toolbar" style="display: none;">
		<input type="file" id="openFile" style="display:none;" onchange="fileLoaded(this, updateBN)" accept=".xdsl,.dne">
		<button type="button" onclick="app.loadFile()">Load File</button>
		<button type="button" onclick="app.saveFile()">Save File</button>
		<button onclick="app.updateBN()">Update</button>
		Example BNs: <select class="exampleBns">
		<option></option>
		<option>Asia.xdsl</option>
		<option>RS Latch.xdsl</option>
		<option>Umbrella.xdsl</option>
		<option>Water.xdsl</option>
		</select>
		<input type="range" name="viewZoom" min="0.25" max="3" step="0.25" value="1"> <span class="viewZoomText">100%</span>
		<button type="button" onclick="app.findGoodDecisions()" class="decisionNet">Find Good Decisions</button>
		<button type="button" onclick="app.autoLayout()">Auto Layout</button>
		# Samples: <input type="text" name="iterations" value="1000">
	</div>
	<div class="bnouterview"><div class="bnview"></div></div>
	<div class="status">(No net loaded.)</div>
	<!--div class=a>a</div>
	<div class=b>b</div>
	<div class=c>c</div-->
	<a id="download" href="" download=""></a>
	<script type="text/plain" class="dneGrammar">
		DNE = DNE_ITEM*
		DNE_ITEM! = COMMENT | STATEMENT@ | BLANK
		COMMENT! = /\/\/.*/ EOL
		WSC! = /\s*/ COMMENT? /\s*/
		WSC_REQ! = /\s+/ COMMENT? /\s*/ | /\s*/ COMMENT? /\s+/
		BLANK = WSC EOL
		EOL = /\r?\n|$/
		STATEMENT! = ASSIGN_STATEMENT@ | BLOCK_STATEMENT@
		BLOCK_STATEMENT = WSC BLOCK_TYPE WSC_REQ NAME WSC /\{/! WSC BLOCK_BODY WSC /\}/! WSC /;/! WSC
		ANON_BLOCK_EXPR = WSC BLOCK_TYPE WSC /\{/! WSC BLOCK_BODY WSC /\}/! WSC
		BLOCK_BODY = DNE_ITEM*
		ASSIGN_STATEMENT = WSC NAME WSC /=/ WSC ASSIGN_EXPR WSC /;/! WSC
		ASSIGN_EXPR! = ANON_BLOCK_EXPR@ | BASIC_EXPR@
		BASIC_EXPR = /"/ DQ_VALUE@! /"/ | /'/ SQ_VALUE@! /'/ | UQ_VALUE@!
		DQ_VALUE = /(\\.|[^"])*/
		SQ_VALUE = /(\\.|[^'])*/
		UQ_VALUE = /[^;]*/
		NAME! = ID@
		BLOCK_TYPE! = ID@
		ID! = /[a-zA-Z][a-zA-Z0-9]*/@
	</script>
</body>
</html>