<!--
Copyright (c) 2014-2015 Steven Mascaro

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<!doctype HTML>
<html>
<head>
	<title>Make-Believe (R10)</title>
	<script src="jquery.min.js"></script>
	<script src="beliefUpdate_worker.js"></script>
	<script src="sylvester.js"></script>
	<script src="dagre.min.js"></script>
	<script src="menu.js"></script>
	<link href="menu_styles.css" type="text/css" rel="stylesheet" />
	<script src="menu_styles.js"></script>
	<script>
	var titlePostfix = "Make-Believe (R10)";
	var openBns = [];
	var currentBn = null;

	String.prototype._splitNotEmpty = function() {
		return this.length==0 ? [] : this.split.apply(this, arguments);
	}

	function getQs() {
		var params = {};
		var argSpecs = window.location.search.substring(1).split('&');
		if (window.location.search) {
			for (var i in argSpecs) {
				var argInfo = argSpecs[i].split('=');
				params[unescape(argInfo[0])] = unescape(argInfo[1]);
			}
		}
		return params;
	}

	window.qs = getQs();

	function loadFile() {
		$("#openFile").click();
	}

	function baseName(fileName) {
		var m = fileName.match(/[^/]*$/);
		if (m) {
			return m[0];
		}
		return null;
	}

	function fileLoaded(inp) {
		var file = inp.files[0];
		console.debug(file);
		var reader = new FileReader();
		reader.onload = function(e) {
			openBns.push(new BN({source: e.target.result, outputEl: $(".bnview")}));
			currentBn = openBns[openBns.length-1];
			currentBn.fileName = baseName(file.name);
			$(".status").text(currentBn.nodes.length+" nodes");
		}
		reader.readAsText(file);
	}

	function loadFromServer(fileName, callback) {
		$.get(fileName, function(data) {
			openBns.push(new BN({source: data, outputEl: $(".bnview")}));
			currentBn = openBns[openBns.length-1];
			currentBn.fileName = baseName(fileName);
			document.title = baseName(fileName) + " - " + titlePostfix;
			$(".status").text(currentBn.nodes.length+" nodes");
			if (callback)  callback();
		}, "text");
	}

	function updateBN(callback) {
		currentBn.updateAndDisplayBeliefs(null, callback);
	}

	function newArray(size, initial) {
		var arr = new Array(size);

		for (var i=0; i<size; i++) {
			arr[i] = initial;
		}

		return arr;
	}

	function renewArray(arr, initial) {
		var size = arr.length;

		for (var i=0; i<size; i++) {
			arr[i] = initial;
		}

		return arr;
	}

	function numNodeStateCombinations(nodes) {
		var numNodeStates = 1;
		for (var j=0; j<nodes.length; j++) {
			numNodeStates *= nodes[j].states.length;
		}
		return numNodeStates;
	}

	function initialStates(nodes) {
		return newArray(nodes.length, 0);
	}

	function nextStates(nodes, states) {
		for (var j=nodes.length-1; j>=0; j--) {
			states[j]++;
			if (states[j] < nodes[j].states.length)  break;
			else                                      states[j] = 0;
		}
		return j >= 0;
	}

	/** Dialogs **/
	function popupDialog($a) {
		if (typeof($a)=="string") {
			$a = $("<div class=dialog>")
				.html($a)
				.appendTo("body");
		}
		var $veil = $("<div class=veil>").width($(window).width()).height($(window).height())
			.css({opacity: 0})
			.animate({opacity: 0.5}, 300)
			.appendTo($("body"));


		var w = $a.outerWidth(),
			h = $a.outerHeight();
		$a.fadeIn(300);

		$a.css({left: (($(window).width() - w)/2)+"px"});
		$a.css({top:(($(window).height() - h)/2)+"px"});

		$a.data("veil", $veil);
	}

	function reportError(msg) {
		popupDialog(msg+"<div class=controls><button type=button onclick=dismissDialogs()>OK</button></div>");
	}

	function dismissDialog($a, callback) {
		$a.fadeOut(300);
		$a.data("veil").animate({opacity: 0}, 300, function() { $(this).hide(); if (callback)  callback(); });
		$a.data("veil").remove();
		$a.remove();
	}

	function dismissDialogs(callback) {
		var first = true;
		var $dialogs = $();
		$(".dialog:visible").each(function() {
			$dialogs.add(dismissDialog($(this), first ? callback : null));
			first = false;
		});
	}
	/** End Dialogs **/

	/** To create a node, call new Node({opt1:...,opt2:...}) **/
	function Node(o) {
		/*
			Member vars and their defaults
		*/
		/// The node's ID (as per GeNIe)
		this.id = null;
		/// The node's label (equivalent to Netica's 'title', or GeNIe's 'name')
		this.label = null;
		/// Type of node: nature, decision, utility
		this.type = "nature";
		/// A list of states XXX
		this.states = [];
		/// A map of state ids -> position in states array
		this.statesById = {};
		/// Pointers to the parents of this node
		this.parents = [];
		/// Pointers to the children of this node
		this.children = [];
		/// The CPT, preferably as a typed float array (only if discrete probabilistic)
		this.cpt = null;
		/// The deterministic function table (only if discrete deterministic)
		this.funcTable = null;
		/// The utilities associated with this node's states
		this.utilities = [];
		/// The current beliefs for this node (net must have been updated separately)
		this.beliefs = null;
		/// 'counts' (per state) and 'seen' (for the whole node) are generated
		/// during simulation belief update. A little bit
		/// like 'experience' in Netica, but not really.
		this.counts = null;
		this.seen = 0;
		/// In a DBN, the time-dependent version of the CPT/funcTable (e.g. t=0, t=1, etc. within a CPT in GeNIe)
		this.dbnOrder = 0;
		/// In a DBN, what temporal step this node falls into
		this.slice = 0;
		/// Whether this node is a dynamic node
		this.dynamic = false;
		/// Parents of nodes in slices t>0. Each parent should be specified as [<parent>,<order>]
		this.dynamicParents = [];
		/// Whether this node should be visible to the engine only, and not the user
		this.engineOnly = false;

		/// Visual properties
		this.pos = {x: 0, y: 0};
		this.size = {width: 0, height: 0};

		/// Set options based on constructor args
		for (var i in o) {
			this[i] = o[i];
		}
	}
	Node.prototype = {
		numParentCombinations: function() {
			var numParentStates = 1;
			for (var j=0; j<this.parents.length; j++) {
				numParentStates *= this.parents[j].states.length;
			}
			return numParentStates;
		},
	};

	/**
	'engineOnly' means node is only visible to the engine, not in the interface
	**/
	function makeNodeFromXdslEl(el, $xdsl, opts) {
		opts = opts || {};
		opts.engineOnly = opts.engineOnly || false;

		var $el = $(el);
		var states = $el.find("state").toArray().map(function(a){ return {id:$(a).attr("id")}; });
		var stateIndex = {}; states.forEach(function(a,i) { stateIndex[a.id] = i; });
		var cpt = null;
		var funcTable = null;
		var utils = null;

		if ($el.is("cpt")) {
			cpt = $el.find("probabilities").text()._splitNotEmpty(/\s+/).map(function(p){return parseFloat(p)});
		}
		else if ($el.is("deterministic")) {
			var map = $el.find("resultingstates").text()._splitNotEmpty(/\s+/);
			funcTable = [];
			for (var i in map) {
				funcTable.push( stateIndex[map[i]] );
			}
			/*/// Go through and convert/expand each row from single-deterministic value to probabilities
			cpt = [];
			for (var i in map) {
				var toState = stateIndex[map[i]];
				console.log("toState:", toState);
				for (var j=0; j<states.length; j++) {
					cpt.push(toState==j ? 1 : 0);
				}
			}
			console.log(cpt);*/

		}
		else if ($el.is("decision")) {
			/// Replace with uniform CPT --- later, though, because we don't necessarily know
			/// enough about the parents yet
		}
		else if ($el.is("utility")) {
			utils = $el.find("utilities").text()._splitNotEmpty(/\s+/).map(function(p){return parseFloat(p)});
			states = utils.map(function(a){ return {id: a} });
			funcTable = [];
			for (var i in utils) {
				funcTable[i] = i;
			}
		}
		var $extInfo = $xdsl.find("> extensions > genie > node#"+$el.attr("id"));
		var posInfo = $extInfo.find("position").text().split(/\s+/);

		/// We will define what we can for Node, and then fix things
		/// up later.
		var node = new Node({
			id: $el.attr("id"),
			label: $el.attr("name"),
			type: $el.is("decision") ? "decision" : $el.is("utility") ? "utility" : "nature",
			states: states,
			parents: $el.find("parents").text()._splitNotEmpty(/\s+/),
			cpt: cpt,
			funcTable: funcTable,
			utilities: utils,
			dbnOrder: $el.is("[order]") ? Number($el.attr("order")) : 0,
			dynamic: $el.attr("dynamic")=="plate",
			engineOnly: opts.engineOnly,
			pos: {x: Number(posInfo[0]), y: Number(posInfo[1])},
			size: {width: Number(posInfo[2]), height: Number(posInfo[3])},
		});
		console.log(node, $extInfo);
		node.beliefs = newArray(node.states.length,0);
		node.counts = newArray(node.states.length,0);
		return node;
	}

	function BN(o) {
		o = o || {};
		o.format = o.format || "xdsl";

		this.source = o.source;
		this.sourceFormat = o.format;
		this.outputEl = $(o.outputEl);

		/// Use worker threads to do belief updating?
		this.useWorkers = false;
		this._workers = [];
		this.numWorkers = 1;

		this.evidence = {};

		/// Does the cache information need updating?
		this.cacheDirty = false;
		/// (No longer true: These are intended to be cache-only. To update the net, call the modification functions
		/// (once they''re written!) or change this.objs and then call this.updateCache.)
		this.nodes = [];
		this._utilityNodes = [];
		this._decisionNodes = [];
		this.nodesById = {};
		this._rootNodes = [];
		this._nodeOrdering = [];

		this.getRowIInts = new Int32Array(new ArrayBuffer(2*4));

		this.init();
	}
	BN.prototype = {
		init: function() {
			this.iterations = 1000;

			this["load_"+this.sourceFormat](this.source);
			this.display();
		},
		/// All load/save functions for different formats have the format 'load_<format>' or
		/// 'save_<format>'.
		load_xdsl: function(xdsl) {
			this.objs = $(xdsl);

			var bn = this;
			this.nodes = [];
			this._utilityNodes = [];
			this._decisionNodes = [];
			this.nodesById = {};
			this._rootNodes = [];
			this.objs.find("> nodes cpt, > nodes deterministic, > nodes decision, > nodes utility").each(function() {
				var node = makeNodeFromXdslEl(this, bn.objs);
				bn.nodes.push(node);
				bn.nodesById[node.id] = node;
				if ($(this).is("utility")) {
					bn._utilityNodes.push(node);
				}
				else if ($(this).is("decision")) {
					bn._decisionNodes.push(node);
				}
				//onsole.debug(bn.nodes);
			});

			if (this._decisionNodes.length) {
				$(".decisionNet").css('display', 'inline');
			}
			else {
				$(".decisionNet").hide();
			}

			/*this.objs.find("> nodes utility").each(function() {
				var node = makeNodeFromXdslEl(this, bn.objs);
				/// Keep utility nodes separate from the nodes involved in inference
				bn._utilityNodes.push(node);
				/// Just add to the standard node index
				bn.nodesById[node.id] = node;
			});*/

			/// Augment the nodes with any dynamic nodes (including unrolled nodes...)
			this.objs.find("> dynamic").each(function() {
				var $dyn = $(this);
				var nodesInSlice = [];
				numSlices = $dyn.attr("numslices");
				///Override with 10
				numSlices = 10;
				var sliceNum = 1;

				for (; sliceNum<numSlices; sliceNum++) {
					function updateParentNames(node) {
						for (var pi=0; pi<node.parents.length; pi++) {
							var parentName = node.parents[pi];
							var parentSlice = sliceNum-node.dbnOrder;
							if (parentSlice!=0) {
								node.parents[pi] = parentName +"_"+(sliceNum-node.dbnOrder);
							}
						}
					}

					bn.objs.find("> nodes cpt, > nodes deterministic, > nodes decision, > nodes utility").each(function() {
						var node = makeNodeFromXdslEl(this, bn.objs, {engineOnly:true});
						node.id = node.id +"_"+ sliceNum;
						node.slice = sliceNum;
						bn.nodes.push(node);
						bn.nodesById[node.id] = node;
						updateParentNames(node);
						//onsole.debug(bn.nodes);
					});

					$dyn.find("> cpt, > deterministic, > nodes decision, > nodes utility").each(function() {
						var tempNode = makeNodeFromXdslEl(this, bn.objs, {engineOnly:true});
						tempNode.id = tempNode.id+"_"+sliceNum;
						var node = bn.nodesById[tempNode.id];

						/// If we've seen enough slices to accommodate the node's DBN order,
						/// start including the node in network
						if (sliceNum >= tempNode.dbnOrder) {
							/// Merge in parents for this slice
							updateParentNames(tempNode);
							if (tempNode.parents)  node.parents = node.parents.concat(tempNode.parents);
							/// Use the cpt for this slice
							node.cpt = tempNode.cpt;
						}
					});
				}

			});

			/// Store the parents/order of all dynamic nodes (useful for display)
			this.objs.find("> dynamic > cpt").each(function() {
				var node = bn.nodesById[$(this).attr("id")];
				var parentNames = $(this).find("parents").text().split(/\s+/);
				for (var pi=0; pi<parentNames.length; pi++) {
					node.dynamicParents.push( [bn.nodesById[parentNames[pi]], Number($(this).find("cpt").attr("order")) ] );
				}
			});

			console.log(bn.nodes);


			/// Replace references to parent ids, with references to node cache
			/// and index each node''s children
			/// The var i in bn.nodes approach causes a 4x slowdown in inference!
			/// Presumably because intId can't be pegged as an int
			for (var i=0; i<bn.nodes.length; i++) {
			//for (var i in bn.nodes) {
				var node = bn.nodes[i];
				/// For fast referencing (without going to a dict lookup)
				node.intId = i;
				for (var j in node.parents) {
					node.parents[j] = bn.nodesById[node.parents[j]];
					node.parents[j].children.push(node);
				}
				for (var j in node.states) {
					node.statesById[node.states[j].id] = j;
				}
				console.log(node._name, node);
			}
			/// Set uniform CPTs for decision nodes
			for (var i in bn.nodes) {
				var node = bn.nodes[i];
				if (node.type == "decision") {
					var len = node.numParentCombinations()*node.states.length;
					var cpt = [];
					for (var j=0; j<len; j++) {
						cpt.push(1/node.states.length);
					}
					node.cpt = cpt;
				}
			}
			/// Replace ordinary CPT arrays with typed arrays
			for (var i in bn.nodes) {
				var node = bn.nodes[i];
				if (ArrayBuffer) {
					if (node.cpt) {
						var cptBuf = new ArrayBuffer(node.cpt.length*4);
						var newCpt = new Float32Array(cptBuf);
						for (var i=0; i<node.cpt.length; i++) {
							newCpt[i] = node.cpt[i];
						}
						node.cpt = newCpt;
					}
					else if (node.funcTable) {
						var ftBuf = new ArrayBuffer(node.funcTable.length*4);
						var newFt = new Int32Array(ftBuf);
						for (var i=0; i<node.funcTable.length; i++) {
							newFt[i] = node.funcTable[i];
						}
						node.funcTable = newFt;
					}
				}
			}
			/// Cache root nodes
			for (var i in bn.nodes) {
				var node = bn.nodes[i];
				if (node.parents.length == 0) {
					bn._rootNodes.push(node);
				}
			}


			function arcCopies(node) {
				node._tempParents = node.parents.slice();
			}
			for (var i=0; i<bn.nodes.length; i++)  arcCopies(bn.nodes[i]);

			/// Create a node ordering that can be used to generate cases quickly (from roots down)
			var q = bn._rootNodes.slice();
			var no = [];
			for (var i=0; i<q.length; i++) {
				var node = q[i];
				no.push(node);
				for (var j=0; j<node.children.length; j++) {
					var allParentsRemoved = true;
					for (var k=0; k<node.children[j]._tempParents.length; k++) {
						if (node.children[j]._tempParents[k] == node) {
							node.children[j]._tempParents[k] = null;
						}
						if (node.children[j]._tempParents[k] != null) {
							allParentsRemoved = false;
						}
					}
					if (allParentsRemoved) {
						q.push(node.children[j]);
					}
				}
			}
			this._nodeOrdering = q;
			console.log("nodeOrdering:", this._nodeOrdering.length);
		},
		/// Returns an xdsl string
		save_xdsl: function() {
			var bn = this;
			var $smile = $("<smile version='1.0' id='sub0'>")
				/// XXX Clarify the difference btw numsamples/discsamples
				.attr("numsamples", this.iterations)
				.attr("discsamples", this.iterations);
			$smile.append("<nodes>");
			for (var i=0; i<this.nodes.length; i++) {
				var node = this.nodes[i];
				var $cpt = null;
				$smile.find("> nodes").append(
					$cpt = $("<cpt>").attr("id", node.id)
				);
				(function(){
				for (var i=0; i<node.states.length; i++) {
					var $state = $("<state>").attr("id", node.states[i].id);
					$cpt.append($state);
				}
				var $parents = $("<parents>");
				var p = "";
				for (var i=0; i<node.parents.length; i++) {
					p += (i!=0?" ":"") + node.parents[i].id;
				}
				if (p!=="")  $cpt.append($parents.text(p));
				$cpt.append(
					$("<probabilities>").text(Array.slice(node.cpt).join(" "))
				);
				})();
			}
			$smile.append(
				'<extensions><genie version="1.0" app="GeNIe 2.0.5219.0" name="Sub0" faultnameformat="nodestate"></genie></extensions>'
			);
			for (var i=0; i<this.nodes.length; i++) {
				var node = this.nodes[i];
				var $node = $("<node>").attr("id", node.id);
				$node
					.append($("<name>").text(node.label ? node.label : node.id))
					.append($("<position>").text(node.pos.x+" "+node.pos.y+" "+node.size.width+" "+node.size.height))
					/// GeNIe is awfully fussy
					.append('<interior color="e5f6f7" />\
				<outline color="0000bb" />\
				<font color="000000" name="Arial" size="8" />')
				$smile.find("> extensions > genie").append($node);
			}
			return '<?xml version="1.0"?>' + $smile[0].outerHTML;
		},
		setUpdateMethod: function(method) {
			this.updateBeliefs = this["updateBeliefs_"+method];
		},
		updateBeliefs: function() {
			currentBn.expectedValue = null;

			this.updateBeliefs_local();

			/// XXXXXX Calculating net's current expected value
			if (this._utilityNodes.length) {
				var totalUtility = 0;
				for (var i=0; i<this._utilityNodes.length; i++) {
					var uNode = this._utilityNodes[i];
					var ev = 0;
					for (var i in uNode.utilities) {
						ev += uNode.utilities[i]*uNode.beliefs[i];
					}
					totalUtility += ev;
				}
				currentBn.expectedValue = totalUtility;
			}
		},
		updateBeliefs_worker: function(callback) {
			var bn = this;
			/// Extract the key parts of the BN needed to do the inference
			var bnToPass = {nodes: []};
			for (var k in bn) {
				if (typeof(bn[k])!="function") {
					bnToPass[k] = bn[k];
				}
			}
			bnToPass.objs = null;
			bnToPass.outputEl = null;
			bnToPass._workers = null;

			/// Convert evidence to array
			var evidenceArr = new Int32Array(new ArrayBuffer(bn.nodes.length*4));
			for (var i=0; i<evidenceArr.length; i++)  evidenceArr[i] = -1;
			for (var i in this.evidence)  evidenceArr[bn.nodesById[i].intId] = Number(this.evidence[i]);

			var numWorkers = this.numWorkers;

			/// Make the workers and store the BN just once
			if (!this._workers.length) {
				this._workers = [];
				for (var wi=0; wi<numWorkers; wi++) {
					this._workers[wi] = new Worker("beliefUpdate_worker.js");
					this._workers[wi].postMessage([0, bnToPass]);
				}
			}

			if (false) {
				updateBeliefs_local(bnToPass, evidenceArr);
				if (callback)  callback(bn);
			}
			else {
				var numComplete = 0;
				for (var wi=0; wi<numWorkers; wi++) {
					var w = this._workers[wi];
					w.postMessage([1, evidenceArr, bn.iterations]);
					w.onmessage = function(e) {
						if (e.data[0]==0) {
							numComplete++;
							var workerBeliefs = e.data[1];
							for (var i=0; i<workerBeliefs.length; i++) {
								/*console.log(workerBn.nodes[i].id, workerBn.nodes[i].beliefs);*/
								if (numComplete==1) {
									bn.nodes[i].beliefs = workerBeliefs[i];
								}
								else {
									var allBeliefs = bn.nodes[i].beliefs;
									for (var bi=0; bi<allBeliefs.length; bi++) {
										allBeliefs[bi] += workerBeliefs[i][bi];
										if (numComplete == numWorkers) {
											allBeliefs[bi] /= numComplete;
										}
									}
								}
							}
							if (numComplete == numWorkers) {
								if (callback)  callback(bn);
							}
						}
						else if (e.data[0] == 1) {
							console.log(e.data);
						}
					};
				}
			}
		},
		updateBeliefs_local: function() {
			var bn = this;
			var cas = new Int32Array(new ArrayBuffer(bn.nodes.length*4));

			for (var i=0; i<bn.nodes.length; i++) {
				var node = bn.nodes[i];
				renewArray(node.counts, 0);
				node.seen = 0;
			}

			/// Convert evidence to array
			var evidenceArr = new Int32Array(new ArrayBuffer(bn.nodes.length*4));
			for (var i=0; i<evidenceArr.length; i++)  evidenceArr[i] = -1;
			for (var i=0; i<this.evidence.length; i++)  evidenceArr[bn.nodesById[i].intId] = Number(this.evidence[i]);

			/// Generate cases
			for (var i=0; i<this.iterations; i++) {
				var weight = this.generateCase(evidenceArr, cas);

				/// For each state of a non-E node, count occurrence given E
				//onsole.log(evidenceArr, Array.apply([], cas), weight);
				for (var intId=0; intId<cas.length; intId++) {
					var node = bn.nodes[intId];
					//node.counts[cas[v]] += 1;
					//node.seen += 1;
					// Do likelihood weighting instead
					node.counts[cas[intId]] += weight;
					node.seen += weight;
				}
			}

			for (var i=0; i<bn.nodes.length; i++) {
				var node = bn.nodes[i];
				for (var j=0; j<node.beliefs.length; j++) {
					if (node.seen>0)  node.beliefs[j] = node.counts[j]/node.seen;
				}
			}
		},
		generateCase: function(evidence, cas) {
			var bn = this;

			var weight = 1;

			/// Run through nodes in topological order
			var numNodes = bn._nodeOrdering.length;
			var ni=0;
			for (;ni < numNodes; ni++) {
				var _node = bn._nodeOrdering[ni];
				cas[_node.intId] = 0;

				/** I believe inlining this is very slightly quicker **/
				//var rowI = this._getRowI(_node.parents, cas);
				var parents = _node.parents;
				var rowI = 0;
				var multiplier = 1;
				for (var pi=parents.length-1; pi>=0; pi--) {
					rowI += multiplier*cas[parents[pi].intId];
					multiplier *= parents[pi].states.length;
				}
				//return rowI;

				if (_node.cpt) {
					if (evidence[_node.intId] != -1) {
						/// Force evidence
						cas[_node.intId] = evidence[_node.intId];

						/// Calculate likelihood of evidence
						var likelihood = _node.cpt[rowI*_node.states.length + cas[_node.intId]];
						weight *= likelihood;
					}
					else {
						/// Generate state for node
						var stateProbs = _node.cpt;

						var parents = _node.parents;
						//onsole.debug("parents", parents);

						var currentSum = 0;
						var rowStart = rowI*_node.states.length;
						var rowEnd = (rowI+1)*_node.states.length-1;
						//onsole.debug("rowStart/End", parents, rowI, rowStart, rowEnd, Array.apply([], _node.cpt).slice(rowStart,rowEnd+1));
						var r = Math.random();
						for (var i=rowStart; i<=rowEnd; i++) {
							var stateProb = stateProbs[i];
							currentSum += stateProb;
							//onsole.debug(r, currentSum);
							if (r < currentSum) {
								cas[_node.intId] = (i-rowStart);
								break;
							}
						}
					}
				}
				else if (_node.funcTable) {
					if (evidence[_node.intId] != -1) {
						/// Force evidence
						cas[_node.intId] = evidence[_node.intId];

						/// Calculate likelihood of evidence (which is either 0 or 1)
						weight *= (_node.funcTable[rowI] == cas[_node.intId] ? 1 : 0);
					}
					else {
						/// Get the deterministic state
						cas[_node.intId] = _node.funcTable[rowI];
					}
				}
			}

			return weight;
		},
		_getRowI: function(parents, cas) {
			var rowI = 0;
			var multiplier = 1;
			for (var pi=parents.length-1; pi>=0; pi--) {
				rowI += multiplier*cas[parents[pi].intId];
				multiplier *= parents[pi].states.length;
			}
			return rowI;
		},
		searchDecisionsAll: function() {
			var decStates = initialStates(this._decisionNodes);
			var origEvidence = $.extend({}, this.evidence);
			var combList = new Array(numNodeStateCombinations(this._decisionNodes));
			origIterations = this.iterations;
			this.iterations = 1000;
			var j = 0;
			window.iter = 0;
			do {
				window.iter++;
				for (var i=0; i<decStates.length; i++) {
					this.evidence[this._decisionNodes[i].id] = decStates[i];
				}
				this.updateBeliefs();
				combList[j] = [this.expectedValue,JSON.stringify(decStates)];
				j++;
			} while (nextStates(this._decisionNodes, decStates));
			this.iterations = origIterations;
			this.evidence = origEvidence;
			combList.sort(function(a,b) {
				return b[0] - a[0];
			});
			var list = [];
			for (var i=0; i<20 && i<combList.length; i++) {
				var decStates = JSON.parse(combList[i][1]);
				var str = "";
				var sep = "";
				for (var d=0; d<decStates.length; d++) {
					str += sep + this._decisionNodes[d].id+'='+this._decisionNodes[d].states[decStates[d]].id;
					sep = ", ";
				}
				list.push(str+" --> "+combList[i][0]);
			}
			//onsole.log(combList);
			return list;
		},
		/// XXX: This is not done right. (Should be OK for dec nodes, but not anything else.) Need to fix.
		topologicalSort: function(nodes) {
			/// Create a node ordering that can be used to generate cases quickly (from roots down)
			var q = [];

			/// Create copies of parents, that we can freely modify
			for (var i=0; i<nodes.length; i++) {
				nodes[i]._tempParents = [];
				for (var j=0; j<nodes[i].parents.length; j++) {
					/// Only add parents from 'nodes'
					if (nodes.indexOf(nodes[i].parents[j])!=-1) {
						nodes[i]._tempParents.push(nodes[i].parents[j]);
					}
				}
			}

			/// Start with finding root nodes
			for (var i=0; i<nodes.length; i++) {
				if (nodes[i]._tempParents.length==0) {
					q.push(nodes[i]);
				}
			}

			/// q starts with root nodes only
			for (var i=0; i<q.length; i++) {
				var node = q[i];
				/// Only keep children which are in 'nodes'
				var childNodes = [];
				for (var j=0; j<node.children.length; j++) {
					if (nodes.indexOf(node.children[j])!=-1) {
						childNodes.push(node.children[j]);
					}
				}
				for (var j=0; j<childNodes.length; j++) {
					var allParentsRemoved = true;
					for (var k=0; k<childNodes[j]._tempParents.length; k++) {
						if (childNodes[j]._tempParents[k] == node) {
							childNodes[j]._tempParents[k] = null;
						}
						if (childNodes[j]._tempParents[k] != null) {
							allParentsRemoved = false;
						}
					}
					if (allParentsRemoved) {
						q.push(childNodes[j]);
					}
				}
			}
			return q;
		},
		searchDecisionsOrdered: function() {
			var decNodes = this.topologicalSort(this._decisionNodes);
			var decStates = [];
			var origEvidence = $.extend({}, this.evidence);
			var origIterations = this.iterations;
			this.iterations = 10000;
			for (var i=0; i<decNodes.length; i++) {
				var maxJ = -1;
				var maxEv = -1;
				for (var j=0; j<decNodes[i].states.length; j++) {
					this.evidence[decNodes[i].id] = j;
					this.updateBeliefs();
					if (this.expectedValue > maxEv) {
						maxEv = this.expectedValue;
						maxJ = j;
					}
				}
				decStates[i] = maxJ;
				this.evidence[decNodes[i].id] = maxJ;
			}
			this.updateBeliefs();
			ev = this.expectedValue;
			this.iterations = origIterations;
			this.evidence = origEvidence;
			return [ev, JSON.stringify(decStates)];
		},
		perfTest: function() {
			console.profile("Starting...");
			this.updateBeliefs_local(1000);
			console.profileEnd("Stopped.");
			console.debug(this.nodes);
		},
		perfCheck: function() {
			var t, dt, st = 0;
			for (var i=0; i<100; i++) {
				t = performance.now();
				this.updateBeliefs_local(1000);
				dt = performance.now() - t;
				st += dt;
			}
			alert(st/100);
		},
		/// nodeRef: for now, the id as a string
		getBeliefs: function(nodeRef) {

		},
		getAllBeliefs: function() {

		},
		getDbnNodeInstances: function(id) {
			var sliceNum = 0;
			var sliceNodes = [];

			while (true) {
				var sliceNode = this.nodesById[id+(sliceNum==0 ? "" : "_"+sliceNum)];
				if (!sliceNode)  break;

				sliceNodes.push(sliceNode);
				sliceNum++;
			}

			return sliceNodes;
		},
		setNodeStates: function(nodes, state) {
			//currentBn.nodesById[nodeId].statesById[$(this).text()]
			for (var i=0; i<nodes.length; i++) {
				currentBn.evidence[nodes[i].id] = state;
			}
		},
		getDbnBeliefs: function(id) {
			var sliceNum = 0;
			var allBeliefs = [];

			while (true) {
				var sliceNode = this.nodesById[id+(sliceNum==0 ? "" : "_"+sliceNum)];
				if (!sliceNode)  break;
				allBeliefs.push(sliceNode.beliefs);
				sliceNum++;
			}

			return allBeliefs;
		},
	};

	var draw = {
		getAngle: function(refVector, angledVector) {
			var r = Math.atan2(angledVector[0], angledVector[1]) - Math.atan2(refVector[0], refVector[1]);
			if (r > Math.PI)  r -= 2*Math.PI;
			else if (r < -Math.PI)  r += 2*Math.PI;
			if (r < 0)  r += 2*Math.PI;
			return r;
		},
		getBox: function(el) {
			el = $(el);
			return {x: el.position().left, y: el.position().top, width: el.outerWidth(), height: el.outerHeight()};
		},
		drawArrow: function(outputEl, from, to) {
			var sx = sy = 10; //startX, startY
			var width = Math.abs(from.x - to.x);
			var height = Math.abs(from.y - to.y);

			var firstX, firstY, lastX, lastY, svgX, svgY;
			if (from.x < to.x) { firstX = sx; lastX = sx+width; svgX = from.x; }
			else { firstX = sx+width; lastX = sx; svgX = to.x; }
			if (from.y < to.y) { firstY = sy; lastY = sy+height; svgY = from.y; }
			else { firstY = sy+height; lastY = sy; svgY = to.y; }

			//onsole.debug(svgX, svgY);
			$("<svg width="+(width+20)+" height="+(height+20)+"><defs>\
	<marker id='arrowhead' viewBox='0 0 10 10' refX='10' refY='5' \
	markerUnits='strokeWidth' orient='auto'\
	markerWidth='10' markerHeight='9'>\
	<polyline points='0,0 10,5 0,10 1,5' fill=black/>\
	</marker>\
	</defs><path d='M "+firstX+" "+firstY+" L "+lastX+" "+lastY+"' stroke=black stroke-width=1 marker-end='url(#arrowhead)'/></svg>")
				.css({left: svgX-sx, top: svgY-sy, position: "absolute"})
				.appendTo(outputEl);
		},
		makePolyline: function(width, height, viewWidth, viewHeight, points) {
			var pointsStr = "";
			for (var i=0; i<points.length; i++) {
				pointsStr += points[i][0]+","+points[i][1]+" ";
			}
			return $("<svg width="+(width)+" height="+(height)+" viewBox='0 0 "+viewWidth+" "+viewHeight+"'>\
				<polyline points='"+pointsStr+"' style='fill:none;stroke:black'/>\
				</svg>");
		},
		makeProbabilityLine: function(width, height, points) {
			var fmtPoints = [];
			for (var i=0; i<points.length; i++)  fmtPoints.push([i/(points.length-1)*width,height-points[i]*height]);
			return this.makePolyline(width, height, width, height, fmtPoints);
		},
		drawArrowBetweenBoxes: function(outputEl, par, child) {
			/// Calculate the line that runs between the center of the two boxes
			var parX = par.x + par.width/2;
			var parY = par.y + par.height/2;
			var childX = child.x + child.width/2;
			var childY = child.y + child.height/2;

			/// In the coordinate space of the center point
			var diagVector = [par.width/2, par.height/2];
			var arrowVector = [childX - parX, childY - parY];
			/// These run from 0 to 2PI. The "origin" line starts at about 135 degrees on a typical X-Y plane and moves anti-clockwise
			var angleBetweenDiags = draw.getAngle([-diagVector[0], -diagVector[1]], [-diagVector[0], diagVector[1]]);
			var angleBetween = draw.getAngle([-diagVector[0], -diagVector[1]], arrowVector);
			//onsole.debug("X:", diagVector, arrowVector, angleBetweenDiags, angleBetween);
			var parIntersect = null;
			if (angleBetween < angleBetweenDiags) {
				var p1 = $L([parX, parY], arrowVector),
					p2 = $L([par.x,par.y], [0,1]);
				parIntersect = p1.intersectionWith(p2);
			}
			else if (angleBetween < Math.PI) {
				var p1 = $L([parX, parY], arrowVector),
					p2 = $L([par.x+par.width,par.y+par.height], [1,0]);
				parIntersect = p1.intersectionWith(p2);
			}
			else if (angleBetween < Math.PI + angleBetweenDiags) {
				var p1 = $L([parX,parY], arrowVector),
					p2 = $L([par.x+par.width,par.y+par.height], [0,1]);
				parIntersect = p1.intersectionWith(p2);
			}
			else {
				var p1 = $L([parX, parY], arrowVector),
					p2 = $L([par.x,par.y], [1,0]);
				parIntersect = p1.intersectionWith(p2);
			}

			/// In the coordinate space of the center point
			var diagVector = [child.width/2, child.height/2];
			var arrowVector = [parX - childX, parY - childY];
			/// These run from 0 to 2PI. The "origin" line starts at about 135 degrees on a typical X-Y plane and moves anti-clockwise
			var angleBetweenDiags = draw.getAngle([-diagVector[0], -diagVector[1]], [-diagVector[0], diagVector[1]]);
			var angleBetween = draw.getAngle([-diagVector[0], -diagVector[1]], arrowVector);
			//onsole.debug("X:", diagVector, arrowVector, angleBetweenDiags, angleBetween);
			var childIntersect = null;
			if (angleBetween < angleBetweenDiags) {
				var p1 = $L([childX, childY], arrowVector),
					p2 = $L([child.x,child.y], [0,1]);
				childIntersect = p1.intersectionWith(p2);
			}
			else if (angleBetween < Math.PI) {
				var p1 = $L([childX, childY], arrowVector),
					p2 = $L([child.x+child.width,child.y+child.height], [1,0]);
				childIntersect = p1.intersectionWith(p2);
			}
			else if (angleBetween < Math.PI + angleBetweenDiags) {
				var p1 = $L([childX,childY], arrowVector),
					p2 = $L([child.x+child.width,child.y+child.height], [0,1]);
				childIntersect = p1.intersectionWith(p2);
			}
			else {
				var p1 = $L([childX, childY], arrowVector),
					p2 = $L([child.x,child.y], [1,0]);
				childIntersect = p1.intersectionWith(p2);
			}

			draw.drawArrow(outputEl, {x: parIntersect.e(1), y: parIntersect.e(2)}, {x: childIntersect.e(1), y: childIntersect.e(2)});
		},
	};

	/// Add display capabilities to the BN
	BN.prototype = $.extend(BN.prototype, {
		updateAndDisplayBeliefs: function(outputEl, callback) {
			var bn = this;
			if (this.useWorkers) {
				this.updateBeliefs_worker(function() {
					bn.displayBeliefs(outputEl);
					if (callback)  callback(bn);
				});
			}
			else {
				this.updateBeliefs();
				this.displayBeliefs(outputEl);
				if (callback)  callback(this);
			}
		},
		displayBeliefs: function(outputEl) {
			outputEl = outputEl || this.outputEl;
			for (var i in this.nodes) {
				var node = this.nodes[i];
				if (node.slice != 0)  break;

				var $displayNode = outputEl.find("#display_"+node.id);
				var stateI = 0;
				var allBeliefs = this.getDbnBeliefs(node.id);
				$displayNode.find(".state").each(function() {
					if (node.dynamic) {
						$(this).find(".beliefBarView").html(
							draw.makeProbabilityLine(100, 20, allBeliefs.map(function(a){ return a[stateI]; })).css("border", "solid 1px #ccc")
						);
					}
					else {
						var pc = Math.round(node.beliefs[stateI]*1000)/1000;
						$(this).find(".prob").text(String(pc).replace(/^0\./, '.'));
						$(this).find(".beliefBar").css({width:(pc*100)+'%'});
					}
					stateI++;
				});
			}

			if (this._utilityNodes.length) {
				if (!$(".status .expectedValue").length) {
					$(".status").append('<span class=expectedValue title="Expected value (or utility) of the current network">Expected value: <span class=val></span></span>');
				}
				$(".status .expectedValue .val").text(Math.round(this.expectedValue*1000)/1000);
			}
		},
		display: function(outputEl) {
			outputEl = outputEl || this.outputEl;
			outputEl.empty();
			var bn = this;
			var displayNodes = {};
			var nodeBeliefs = this.getAllBeliefs();
			/// Draw all the nodes
			for (var i=0; i<bn.nodes.length; i++) {
				var node = bn.nodes[i];
				if (node.engineOnly)  continue;

				var $displayNode = displayNodes[node.id] = $("<div class=node id=display_"+node.id+" draggable=true>")
					.css({left: node.pos.x+"px", top: node.pos.y+"px"})
					.append(
						$("<h6>").text(node.label ? node.label : node.id)
					)
					.appendTo(outputEl);
				if (node.dynamic)  $displayNode.addClass("dynamic");
				$displayNode.addClass(node.type);
				for (var j=0; j<node.states.length; j++) {
					var state = node.states[j];
					$displayNode.append(
						$("<div class=state>").append(
							$("<div class=stateName>").text(state.id)
						).append(
							$("\
							<div class=prob></div>\
							<div class=beliefBarView>\
								<div class=beliefBar></div>\
							</div>\
							")
						)
					);
				}
			}
			/// Draw all the arcs
			var allNodes = bn.nodes;
			for (var ni=0; ni<allNodes.length; ni++) {
				var node = allNodes[ni];
				if (node.engineOnly)  continue;

				/// XXX Remove dependency on XDSL
				var parents = node.parents.concat(node.dynamicParents);
				if (parents.length) {
					for (var i=0; i<parents.length; i++) {
						var n = displayNodes[Array.isArray(parents[i]) ? parents[i][0].id : parents[i].id];
						var par = draw.getBox(n);
						//onsole.log("par:", parents[i], par);
						n = displayNodes[node.id];
						var child = draw.getBox(n);
						//onsole.log("child:", node.id, child);

						draw.drawArrowBetweenBoxes(outputEl, par, child);
					}
				}
			}
		},
	});

	var app = {
		loadFile: function() {
			loadFile();
		},
		saveFile: function() {
			$("a#download")
				.attr('href', 'data:text/plain;,'+currentBn.save_xdsl())
				.attr('download', currentBn.fileName)
				[0].click();
		},
		updateBN: function() {
			var start = performance.now();
			updateBN(function() {
				var durationMs = (performance.now() - start);
				if ($(".status .duration").length==0) {
					$(".status").append("<span class=duration title='Time taken for last computation'>Last: <span class=val></span>ms</span>");
				}
				$(".status .duration .val").text(Math.round(durationMs*1000)/1000);
			});
		},
		findGoodDecisions: function() {
			if (!currentBn._decisionNodes.length) {
				popupDialog("<p>This network has no decision nodes.<div class=controls><button type=button class=okButton>OK</button></div>");
				$(".dialog .okButton").one("click", dismissDialogs);
				return;
			}
			var str = "";
			var dec;
			if (numNodeStateCombinations(currentBn._decisionNodes) < 100) {
				dec = currentBn.searchDecisionsAll();
			}
			else {
				str += "<strong>Too many decision combinations. Using decision order instead.</strong>";
				dec = currentBn.searchDecisionsOrdered();
			}
			for (var i=0; i<dec.length; i++) {
				str += "<div>"+dec[i] + "</div>";
			}
			popupDialog(str+"<div class=controls><button type=button class=okButton>OK</button></div>");
			$(".dialog .okButton").one("click", dismissDialogs);
		},
		autoLayout: function() {
			var g = new dagre.graphlib.Graph();
			g.setGraph({});
			g.setDefaultEdgeLabel(function(){ return {}; });

			for (var i=0; i < currentBn.nodes.length; i++) {
				var node = currentBn.nodes[i];
				g.setNode(node.id, { label: (node.label || node.id), width: node.size.width, height: node.size.height} );
			}

			for (var i=0; i < currentBn.nodes.length; i++) {
				var node = currentBn.nodes[i];
				for (var j=0; j < node.children.length; j++) {
					g.setEdge(node.id, node.children[j].id);
				}
			}

			dagre.layout(g);

			g.nodes().forEach(function(nodeId) {
				console.log(currentBn.nodesById[nodeId]);
				currentBn.nodesById[nodeId].pos.x = g.node(nodeId).x;
				currentBn.nodesById[nodeId].pos.y = g.node(nodeId).y;
			});

			currentBn.display();
			currentBn.displayBeliefs();
		},
	};

	$(document).ready(function() {
		var exampleBns = "Asia.xdsl|RS Latch.xdsl|Umbrella.xdsl|Water.xdsl".split(/\|/);
		var exampleBnActions = [];
		for (var i in exampleBns) {
			/// Need html escape function
			exampleBnActions[i] = MenuAction('<span data-name="'+exampleBns[i]+'">'+exampleBns[i]+'</span>', function() {
				window.location.href = "?file=bns/"+$(this).find('span').data("name");
			});
		}

		var menu = Menu({type: "bar", items: [
			Menu({label:"File", items: [
				MenuAction("Open...", function(){ app.loadFile(); dismissActiveMenus(); }),
				MenuAction("Save...", function(){ app.saveFile(); dismissActiveMenus(); }),
				Menu({label: "Example BNs&nbsp;&nbsp; &#9656;", items: exampleBnActions}),
			]}),
			Menu({label:"View", items: [
				MenuAction('<input type="range" name="viewZoom" min="0.25" max="3" step="0.25" value="1"> <span class="viewZoomText">100%</span>', function(){}),
			]}),
			Menu({label:"Network", items: [
				MenuAction("Update", function() { app.updateBN(); dismissActiveMenus(); }),
				MenuAction("Find Good Decisions", function() { app.findGoodDecisions(); dismissActiveMenus(); }),
				MenuAction("Auto-Layout", function() { app.autoLayout(); dismissActiveMenus(); }),
				MenuAction('# Samples: <input type="text" name="iterations" value="1000">', function() { }),
				//MenuAction('(perfcheck)', function() { currentBn.perfCheck(); }),
			]}),
		]});

		$("body").prepend(menu.make());

		$(".bnview").on("click", ".stateName", function() {
			var nodeId = $(this).closest(".node").attr("id").replace(/^display_/, '');
			var node = currentBn.nodesById[nodeId];
			var stateI = node.statesById[$(this).text()];
			if (node.dynamic) {
				var checks = "";
				var selectStr = "<select>";
				selectStr += "<option value=-1>(not set)</option>";
				for (var i=0; i<node.states.length; i++) {
					selectStr += "<option value="+i+">"+node.states[i].id+"</option>";
				}
				selectStr += "</select>";
				for (var i=0; i<10; i++) {
					checks += "<div class='timestep time"+i+"'>"+selectStr+"</div>";
				}
				popupDialog("Please specify the evidence for each time slice:"
					+checks
					+"<div class=controls><button type=button class='okButton'>OK</button></div>");
				var t = 0;
				$(".dialog .timestep").each(function() {
					$(this).find("select").val( currentBn.evidence[nodeId+(t==0?"":"_"+t)] );
					t++;
				});
				$(".dialog .okButton").one("click", function() {
					var t = 0;
					$(".dialog").find(".timestep").each(function() {
						var timeStepVal = $(this).find("select").val();

						if (timeStepVal == -1) {
							delete currentBn.evidence[nodeId+(t==0?"":"_"+t)];
						}
						else {
							currentBn.evidence[nodeId+(t==0?"":"_"+t)] = Number(timeStepVal);
						}
						t++;
					});
					dismissDialogs(function(){currentBn.updateAndDisplayBeliefs()});
				});
			}
			else {
				if (currentBn.evidence[nodeId]) {
					/// Remove the evidence
					var isNewState = currentBn.evidence[nodeId] != stateI;
					delete currentBn.evidence[nodeId];
					/// Set new evidence
					if (isNewState) {
						currentBn.evidence[nodeId] = stateI;
					}
					/// Remove visual indicator of evidence if no new evidence
					else {
						$("#display_"+nodeId).removeClass("hasEvidence");
					}
				}
				else {
					/// Save the evidence
					currentBn.evidence[nodeId] = stateI;

					/// Update display
					$("#display_"+nodeId).addClass("hasEvidence");
				}
				app.updateBN();
			}
		});

		var mx = 0, my = 0;
		$(".bnview").on("mousedown", ".node h6", function(event) {
			mx = event.originalEvent.pageX;
			my = event.originalEvent.pageY;
			var $node = $(this).closest(".node");
			var o = $(this).offset();
			$(".bnview").on("mousemove", function(event) {
				var nmx = event.originalEvent.pageX;
				var nmy = event.originalEvent.pageY;
				$node.offset({left: o.left + (nmx - mx), top: o.top + (nmy - my)});
			});
			$(".bnview").one("mouseup", function(event) {
				var nmx = event.originalEvent.pageX;
				var nmy = event.originalEvent.pageY;
				$node.offset({left: o.left + (nmx - mx), top: o.top + (nmy - my)});
				$(".bnview").unbind("mousemove");

				var n = currentBn.nodesById[$node.attr("id").replace(/^display_/,"")];
				n.pos.x += (nmx - mx);
				n.pos.y += (nmy - my);
				/*var $extInfo = currentBn.objs.find("> extensions > genie > node#"+$node.attr("id").replace(/^display_/,""));
				var pos = $extInfo.find("position").text().split(/\s+/);
				$extInfo.find("position").text((Number(pos[0]) + (nmx - mx))+" "+(Number(pos[1]) + (nmy - my)));*/

				/// Need something much more efficient than this!
				$("#beliefBarAnimations")[0].sheet.disabled = true;
				currentBn.display();
				currentBn.displayBeliefs();
				/// Turn them back on, but not in the current execution block
				window.setTimeout(function() {
					$("#beliefBarAnimations")[0].sheet.disabled = false;
				}, 0);
			});
		});

		$("[name=viewZoom]").on("input change", function(evt) {
			var $range = $(evt.target);
			$(".bnview").css({transformOrigin: 'top left', transform: 'scale('+$range.val()+')'});
			$(".viewZoomText").text(Math.round($range.val()*100)+"%");
		}).on("dblclick", function(evt) {
			var $range = $(evt.target);
			$range.val(1);
			$range.trigger("change");
		});

		/// Handle an example BN load
		$(".exampleBns").on("change", function() {
			window.location.href = "?file=bns/"+$(this).find("option:selected").text();
		});

		/// Handle changes to iterations
		$("[name=iterations]").on("keyup", function(evt) {
			var numIterations = $(evt.target).val();
			currentBn.iterations = numIterations;
		});

		if (window.qs.file) {
			loadFromServer(window.qs.file, updateBN);
		}
	});
	</script>
	<style>
	html, body { height: 100%; width: 100%; margin: 0; padding: 0; }

	body { font-size: 8pt; font-family: arial; }
	.bnview { width: 100%; height: 100%; position: relative; }
	.node { position: absolute; padding: 0 0; border-radius: 0; border: solid 1px #444;
		background: #F9DAB9; z-index: 1; font-family: arial; }
	.node.hasEvidence { background: #FFA87F; }
	.node h6 { font-size: 1em; margin: 0; font-weight: bold; border-bottom: solid 1px #444; padding: 1px; }
	.node.labelledBox .state { display: none; }
	.node.labelledBox { border-radius: 5px; }
	.node .state { display: table-row; cursor: pointer; }
	.node .state > div { display: table-cell; vertical-align: middle; padding: 1px; }
	.node .state .prob { width: 22px; text-align: left; padding-left: 8px; }
	.node .state .beliefBarView { min-width: 50px; position: relative; }
	.node.dynamic .state .beliefBarView { min-width: 100px; height: 26px; }
	.node .state .beliefBar { background: black; height: 10px; width: 0px; }

	.node.decision { background: #A5BEF2; }
	.node.decision .state .prob { visibility: hidden; }
	.node.decision .state .beliefBar { visibility: hidden; }
	.node.decision.hasEvidence .state .beliefBar { visibility: visible; }
	.node.utility { background: #F3A5CD; }
	.node.utility h6 { border-bottom: none; }

	/** Layout **/
	body { display: flex; flex-direction: column; height: 100%; }
	.bnouterview { flex: 1; overflow: auto; width: 100%; }
	.status { background: white;
		border-top: 1px solid #AAA;
		width: 100%; z-index: 1000; opacity: 0.8; }
	.status .expectedValue, .status .duration { margin-left: 1em; }
	.decisionNet { display: none; }

	/** Menus **/
	.menu.bar { border-bottom: 1px solid #aaa; }

	/** Dialogs **/
	.dialog { display: none; position: absolute; z-index: 10000; background: rgb(255,255,255); background: rgba(255,255,255,0.95);
		border: solid 1px black; box-shadow: 2px 2px 2px #888; padding: 1.2em; text-align: center; }
	.dialog.page { width: 80%; height: 70%; }
	.veil { position: absolute; z-index: 1000; background: white; opacity: 0; top: 0; left: 0; }
	</style>
	<style id="beliefBarAnimations">
	.node .state .beliefBar { transition: width 0.3s; }
	</style>
</head>
<body>
	<div class="toolbar" style="display: none;">
		<input type="file" id="openFile" style="display:none;" onchange="fileLoaded(this)" accept=".xdsl">
		<button type="button" onclick="app.loadFile()">Load File</button>
		<button type="button" onclick="app.saveFile()">Save File</button>
		<button onclick="app.updateBN()">Update</button>
		Example BNs: <select class="exampleBns">
		<option></option>
		<option>Asia.xdsl</option>
		<option>RS Latch.xdsl</option>
		<option>Umbrella.xdsl</option>
		<option>Water.xdsl</option>
		</select>
		<input type="range" name="viewZoom" min="0.25" max="3" step="0.25" value="1"> <span class="viewZoomText">100%</span>
		<button type="button" onclick="app.findGoodDecisions()" class="decisionNet">Find Good Decisions</button>
		<button type="button" onclick="app.autoLayout()">Auto Layout</button>
		# Samples: <input type="text" name="iterations" value="1000">
	</div>
	<div class="bnouterview"><div class="bnview"></div></div>
	<div class="status">(No net loaded.)</div>
	<!--div class=a>a</div>
	<div class=b>b</div>
	<div class=c>c</div-->
	<a id="download" href="" download=""></a>
</body>
</html>